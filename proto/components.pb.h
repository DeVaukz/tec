// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components.proto

#ifndef PROTOBUF_components_2eproto__INCLUDED
#define PROTOBUF_components_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace tec {
namespace proto {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_components_2eproto();
void protobuf_AssignDesc_components_2eproto();
void protobuf_ShutdownFile_components_2eproto();

class Renderable;
class Position;
class Position_CenterOffset;
class Orientation;
class Orientation_RotationOffset;
class View;
class Animation;
class Scale;
class CollisionBody;
class CollisionBody_Box;
class CollisionBody_Sphere;
class CollisionBody_Capsule;
class Velocity;
class AudioSource;
class Light;
class Light_Attenuation;
class Light_Direction;
class LuaScript;
class VoxelVolumen;
class ComputerScreen;
class Computer;
class Computer_Device;
class Computer_CPU;
class Computer_CPU_TR3200;
class Component;
class Entity;
class EntityFileList;

// ===================================================================

class Renderable : public ::google::protobuf::Message {
 public:
  Renderable();
  virtual ~Renderable();

  Renderable(const Renderable& from);

  inline Renderable& operator=(const Renderable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Renderable& default_instance();

  void Swap(Renderable* other);

  // implements Message ----------------------------------------------

  inline Renderable* New() const { return New(NULL); }

  Renderable* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Renderable& from);
  void MergeFrom(const Renderable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Renderable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string shader_name = 1;
  bool has_shader_name() const;
  void clear_shader_name();
  static const int kShaderNameFieldNumber = 1;
  const ::std::string& shader_name() const;
  void set_shader_name(const ::std::string& value);
  void set_shader_name(const char* value);
  void set_shader_name(const char* value, size_t size);
  ::std::string* mutable_shader_name();
  ::std::string* release_shader_name();
  void set_allocated_shader_name(::std::string* shader_name);

  // optional string mesh_name = 2;
  bool has_mesh_name() const;
  void clear_mesh_name();
  static const int kMeshNameFieldNumber = 2;
  const ::std::string& mesh_name() const;
  void set_mesh_name(const ::std::string& value);
  void set_mesh_name(const char* value);
  void set_mesh_name(const char* value, size_t size);
  ::std::string* mutable_mesh_name();
  ::std::string* release_mesh_name();
  void set_allocated_mesh_name(::std::string* mesh_name);

  // optional bool hidden = 3;
  bool has_hidden() const;
  void clear_hidden();
  static const int kHiddenFieldNumber = 3;
  bool hidden() const;
  void set_hidden(bool value);

  // @@protoc_insertion_point(class_scope:tec.proto.Renderable)
 private:
  inline void set_has_shader_name();
  inline void clear_has_shader_name();
  inline void set_has_mesh_name();
  inline void clear_has_mesh_name();
  inline void set_has_hidden();
  inline void clear_has_hidden();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr shader_name_;
  ::google::protobuf::internal::ArenaStringPtr mesh_name_;
  bool hidden_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Renderable* default_instance_;
};
// -------------------------------------------------------------------

class Position_CenterOffset : public ::google::protobuf::Message {
 public:
  Position_CenterOffset();
  virtual ~Position_CenterOffset();

  Position_CenterOffset(const Position_CenterOffset& from);

  inline Position_CenterOffset& operator=(const Position_CenterOffset& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Position_CenterOffset& default_instance();

  void Swap(Position_CenterOffset* other);

  // implements Message ----------------------------------------------

  inline Position_CenterOffset* New() const { return New(NULL); }

  Position_CenterOffset* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Position_CenterOffset& from);
  void MergeFrom(const Position_CenterOffset& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Position_CenterOffset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:tec.proto.Position.CenterOffset)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Position_CenterOffset* default_instance_;
};
// -------------------------------------------------------------------

class Position : public ::google::protobuf::Message {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();

  void Swap(Position* other);

  // implements Message ----------------------------------------------

  inline Position* New() const { return New(NULL); }

  Position* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Position* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Position_CenterOffset CenterOffset;

  // accessors -------------------------------------------------------

  // optional float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // optional .tec.proto.Position.CenterOffset offset = 4;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 4;
  const ::tec::proto::Position_CenterOffset& offset() const;
  ::tec::proto::Position_CenterOffset* mutable_offset();
  ::tec::proto::Position_CenterOffset* release_offset();
  void set_allocated_offset(::tec::proto::Position_CenterOffset* offset);

  // @@protoc_insertion_point(class_scope:tec.proto.Position)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_offset();
  inline void clear_has_offset();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  ::tec::proto::Position_CenterOffset* offset_;
  float z_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Position* default_instance_;
};
// -------------------------------------------------------------------

class Orientation_RotationOffset : public ::google::protobuf::Message {
 public:
  Orientation_RotationOffset();
  virtual ~Orientation_RotationOffset();

  Orientation_RotationOffset(const Orientation_RotationOffset& from);

  inline Orientation_RotationOffset& operator=(const Orientation_RotationOffset& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Orientation_RotationOffset& default_instance();

  void Swap(Orientation_RotationOffset* other);

  // implements Message ----------------------------------------------

  inline Orientation_RotationOffset* New() const { return New(NULL); }

  Orientation_RotationOffset* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Orientation_RotationOffset& from);
  void MergeFrom(const Orientation_RotationOffset& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Orientation_RotationOffset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // required float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // required float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:tec.proto.Orientation.RotationOffset)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Orientation_RotationOffset* default_instance_;
};
// -------------------------------------------------------------------

class Orientation : public ::google::protobuf::Message {
 public:
  Orientation();
  virtual ~Orientation();

  Orientation(const Orientation& from);

  inline Orientation& operator=(const Orientation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Orientation& default_instance();

  void Swap(Orientation* other);

  // implements Message ----------------------------------------------

  inline Orientation* New() const { return New(NULL); }

  Orientation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Orientation& from);
  void MergeFrom(const Orientation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Orientation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Orientation_RotationOffset RotationOffset;

  // accessors -------------------------------------------------------

  // required float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // required float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // required float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // required float w = 4;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 4;
  float w() const;
  void set_w(float value);

  // optional .tec.proto.Orientation.RotationOffset offset = 5;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 5;
  const ::tec::proto::Orientation_RotationOffset& offset() const;
  ::tec::proto::Orientation_RotationOffset* mutable_offset();
  ::tec::proto::Orientation_RotationOffset* release_offset();
  void set_allocated_offset(::tec::proto::Orientation_RotationOffset* offset);

  // @@protoc_insertion_point(class_scope:tec.proto.Orientation)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_offset();
  inline void clear_has_offset();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  float w_;
  ::tec::proto::Orientation_RotationOffset* offset_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Orientation* default_instance_;
};
// -------------------------------------------------------------------

class View : public ::google::protobuf::Message {
 public:
  View();
  virtual ~View();

  View(const View& from);

  inline View& operator=(const View& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const View& default_instance();

  void Swap(View* other);

  // implements Message ----------------------------------------------

  inline View* New() const { return New(NULL); }

  View* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const View& from);
  void MergeFrom(const View& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(View* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool active = 1;
  bool has_active() const;
  void clear_active();
  static const int kActiveFieldNumber = 1;
  bool active() const;
  void set_active(bool value);

  // @@protoc_insertion_point(class_scope:tec.proto.View)
 private:
  inline void set_has_active();
  inline void clear_has_active();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool active_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static View* default_instance_;
};
// -------------------------------------------------------------------

class Animation : public ::google::protobuf::Message {
 public:
  Animation();
  virtual ~Animation();

  Animation(const Animation& from);

  inline Animation& operator=(const Animation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Animation& default_instance();

  void Swap(Animation* other);

  // implements Message ----------------------------------------------

  inline Animation* New() const { return New(NULL); }

  Animation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Animation& from);
  void MergeFrom(const Animation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Animation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string animation_name = 1;
  bool has_animation_name() const;
  void clear_animation_name();
  static const int kAnimationNameFieldNumber = 1;
  const ::std::string& animation_name() const;
  void set_animation_name(const ::std::string& value);
  void set_animation_name(const char* value);
  void set_animation_name(const char* value, size_t size);
  ::std::string* mutable_animation_name();
  ::std::string* release_animation_name();
  void set_allocated_animation_name(::std::string* animation_name);

  // @@protoc_insertion_point(class_scope:tec.proto.Animation)
 private:
  inline void set_has_animation_name();
  inline void clear_has_animation_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr animation_name_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Animation* default_instance_;
};
// -------------------------------------------------------------------

class Scale : public ::google::protobuf::Message {
 public:
  Scale();
  virtual ~Scale();

  Scale(const Scale& from);

  inline Scale& operator=(const Scale& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Scale& default_instance();

  void Swap(Scale* other);

  // implements Message ----------------------------------------------

  inline Scale* New() const { return New(NULL); }

  Scale* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Scale& from);
  void MergeFrom(const Scale& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Scale* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:tec.proto.Scale)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Scale* default_instance_;
};
// -------------------------------------------------------------------

class CollisionBody_Box : public ::google::protobuf::Message {
 public:
  CollisionBody_Box();
  virtual ~CollisionBody_Box();

  CollisionBody_Box(const CollisionBody_Box& from);

  inline CollisionBody_Box& operator=(const CollisionBody_Box& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CollisionBody_Box& default_instance();

  void Swap(CollisionBody_Box* other);

  // implements Message ----------------------------------------------

  inline CollisionBody_Box* New() const { return New(NULL); }

  CollisionBody_Box* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CollisionBody_Box& from);
  void MergeFrom(const CollisionBody_Box& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CollisionBody_Box* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x_extent = 1;
  bool has_x_extent() const;
  void clear_x_extent();
  static const int kXExtentFieldNumber = 1;
  float x_extent() const;
  void set_x_extent(float value);

  // required float y_extent = 2;
  bool has_y_extent() const;
  void clear_y_extent();
  static const int kYExtentFieldNumber = 2;
  float y_extent() const;
  void set_y_extent(float value);

  // required float z_extent = 3;
  bool has_z_extent() const;
  void clear_z_extent();
  static const int kZExtentFieldNumber = 3;
  float z_extent() const;
  void set_z_extent(float value);

  // @@protoc_insertion_point(class_scope:tec.proto.CollisionBody.Box)
 private:
  inline void set_has_x_extent();
  inline void clear_has_x_extent();
  inline void set_has_y_extent();
  inline void clear_has_y_extent();
  inline void set_has_z_extent();
  inline void clear_has_z_extent();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_extent_;
  float y_extent_;
  float z_extent_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static CollisionBody_Box* default_instance_;
};
// -------------------------------------------------------------------

class CollisionBody_Sphere : public ::google::protobuf::Message {
 public:
  CollisionBody_Sphere();
  virtual ~CollisionBody_Sphere();

  CollisionBody_Sphere(const CollisionBody_Sphere& from);

  inline CollisionBody_Sphere& operator=(const CollisionBody_Sphere& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CollisionBody_Sphere& default_instance();

  void Swap(CollisionBody_Sphere* other);

  // implements Message ----------------------------------------------

  inline CollisionBody_Sphere* New() const { return New(NULL); }

  CollisionBody_Sphere* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CollisionBody_Sphere& from);
  void MergeFrom(const CollisionBody_Sphere& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CollisionBody_Sphere* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float radius = 1;
  bool has_radius() const;
  void clear_radius();
  static const int kRadiusFieldNumber = 1;
  float radius() const;
  void set_radius(float value);

  // @@protoc_insertion_point(class_scope:tec.proto.CollisionBody.Sphere)
 private:
  inline void set_has_radius();
  inline void clear_has_radius();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float radius_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static CollisionBody_Sphere* default_instance_;
};
// -------------------------------------------------------------------

class CollisionBody_Capsule : public ::google::protobuf::Message {
 public:
  CollisionBody_Capsule();
  virtual ~CollisionBody_Capsule();

  CollisionBody_Capsule(const CollisionBody_Capsule& from);

  inline CollisionBody_Capsule& operator=(const CollisionBody_Capsule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CollisionBody_Capsule& default_instance();

  void Swap(CollisionBody_Capsule* other);

  // implements Message ----------------------------------------------

  inline CollisionBody_Capsule* New() const { return New(NULL); }

  CollisionBody_Capsule* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CollisionBody_Capsule& from);
  void MergeFrom(const CollisionBody_Capsule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CollisionBody_Capsule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float radius = 1;
  bool has_radius() const;
  void clear_radius();
  static const int kRadiusFieldNumber = 1;
  float radius() const;
  void set_radius(float value);

  // required float height = 2;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  float height() const;
  void set_height(float value);

  // @@protoc_insertion_point(class_scope:tec.proto.CollisionBody.Capsule)
 private:
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_height();
  inline void clear_has_height();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float radius_;
  float height_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static CollisionBody_Capsule* default_instance_;
};
// -------------------------------------------------------------------

class CollisionBody : public ::google::protobuf::Message {
 public:
  CollisionBody();
  virtual ~CollisionBody();

  CollisionBody(const CollisionBody& from);

  inline CollisionBody& operator=(const CollisionBody& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CollisionBody& default_instance();

  enum ShapeCase {
    kBox = 3,
    kSphere = 4,
    kCapsule = 5,
    SHAPE_NOT_SET = 0,
  };

  void Swap(CollisionBody* other);

  // implements Message ----------------------------------------------

  inline CollisionBody* New() const { return New(NULL); }

  CollisionBody* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CollisionBody& from);
  void MergeFrom(const CollisionBody& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CollisionBody* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CollisionBody_Box Box;
  typedef CollisionBody_Sphere Sphere;
  typedef CollisionBody_Capsule Capsule;

  // accessors -------------------------------------------------------

  // optional bool disable_deactivation = 1;
  bool has_disable_deactivation() const;
  void clear_disable_deactivation();
  static const int kDisableDeactivationFieldNumber = 1;
  bool disable_deactivation() const;
  void set_disable_deactivation(bool value);

  // optional bool disable_rotation = 2;
  bool has_disable_rotation() const;
  void clear_disable_rotation();
  static const int kDisableRotationFieldNumber = 2;
  bool disable_rotation() const;
  void set_disable_rotation(bool value);

  // optional .tec.proto.CollisionBody.Box box = 3;
  bool has_box() const;
  void clear_box();
  static const int kBoxFieldNumber = 3;
  const ::tec::proto::CollisionBody_Box& box() const;
  ::tec::proto::CollisionBody_Box* mutable_box();
  ::tec::proto::CollisionBody_Box* release_box();
  void set_allocated_box(::tec::proto::CollisionBody_Box* box);

  // optional .tec.proto.CollisionBody.Sphere sphere = 4;
  bool has_sphere() const;
  void clear_sphere();
  static const int kSphereFieldNumber = 4;
  const ::tec::proto::CollisionBody_Sphere& sphere() const;
  ::tec::proto::CollisionBody_Sphere* mutable_sphere();
  ::tec::proto::CollisionBody_Sphere* release_sphere();
  void set_allocated_sphere(::tec::proto::CollisionBody_Sphere* sphere);

  // optional .tec.proto.CollisionBody.Capsule capsule = 5;
  bool has_capsule() const;
  void clear_capsule();
  static const int kCapsuleFieldNumber = 5;
  const ::tec::proto::CollisionBody_Capsule& capsule() const;
  ::tec::proto::CollisionBody_Capsule* mutable_capsule();
  ::tec::proto::CollisionBody_Capsule* release_capsule();
  void set_allocated_capsule(::tec::proto::CollisionBody_Capsule* capsule);

  // optional float mass = 6;
  bool has_mass() const;
  void clear_mass();
  static const int kMassFieldNumber = 6;
  float mass() const;
  void set_mass(float value);

  ShapeCase shape_case() const;
  // @@protoc_insertion_point(class_scope:tec.proto.CollisionBody)
 private:
  inline void set_has_disable_deactivation();
  inline void clear_has_disable_deactivation();
  inline void set_has_disable_rotation();
  inline void clear_has_disable_rotation();
  inline void set_has_box();
  inline void set_has_sphere();
  inline void set_has_capsule();
  inline void set_has_mass();
  inline void clear_has_mass();

  inline bool has_shape() const;
  void clear_shape();
  inline void clear_has_shape();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool disable_deactivation_;
  bool disable_rotation_;
  float mass_;
  union ShapeUnion {
    ShapeUnion() {}
    ::tec::proto::CollisionBody_Box* box_;
    ::tec::proto::CollisionBody_Sphere* sphere_;
    ::tec::proto::CollisionBody_Capsule* capsule_;
  } shape_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static CollisionBody* default_instance_;
};
// -------------------------------------------------------------------

class Velocity : public ::google::protobuf::Message {
 public:
  Velocity();
  virtual ~Velocity();

  Velocity(const Velocity& from);

  inline Velocity& operator=(const Velocity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Velocity& default_instance();

  void Swap(Velocity* other);

  // implements Message ----------------------------------------------

  inline Velocity* New() const { return New(NULL); }

  Velocity* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Velocity& from);
  void MergeFrom(const Velocity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Velocity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float linear_x = 1;
  bool has_linear_x() const;
  void clear_linear_x();
  static const int kLinearXFieldNumber = 1;
  float linear_x() const;
  void set_linear_x(float value);

  // optional float linear_y = 2;
  bool has_linear_y() const;
  void clear_linear_y();
  static const int kLinearYFieldNumber = 2;
  float linear_y() const;
  void set_linear_y(float value);

  // optional float linear_z = 3;
  bool has_linear_z() const;
  void clear_linear_z();
  static const int kLinearZFieldNumber = 3;
  float linear_z() const;
  void set_linear_z(float value);

  // optional float angular_x = 4;
  bool has_angular_x() const;
  void clear_angular_x();
  static const int kAngularXFieldNumber = 4;
  float angular_x() const;
  void set_angular_x(float value);

  // optional float angular_y = 5;
  bool has_angular_y() const;
  void clear_angular_y();
  static const int kAngularYFieldNumber = 5;
  float angular_y() const;
  void set_angular_y(float value);

  // optional float angular_z = 6;
  bool has_angular_z() const;
  void clear_angular_z();
  static const int kAngularZFieldNumber = 6;
  float angular_z() const;
  void set_angular_z(float value);

  // @@protoc_insertion_point(class_scope:tec.proto.Velocity)
 private:
  inline void set_has_linear_x();
  inline void clear_has_linear_x();
  inline void set_has_linear_y();
  inline void clear_has_linear_y();
  inline void set_has_linear_z();
  inline void clear_has_linear_z();
  inline void set_has_angular_x();
  inline void clear_has_angular_x();
  inline void set_has_angular_y();
  inline void clear_has_angular_y();
  inline void set_has_angular_z();
  inline void clear_has_angular_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float linear_x_;
  float linear_y_;
  float linear_z_;
  float angular_x_;
  float angular_y_;
  float angular_z_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Velocity* default_instance_;
};
// -------------------------------------------------------------------

class AudioSource : public ::google::protobuf::Message {
 public:
  AudioSource();
  virtual ~AudioSource();

  AudioSource(const AudioSource& from);

  inline AudioSource& operator=(const AudioSource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioSource& default_instance();

  void Swap(AudioSource* other);

  // implements Message ----------------------------------------------

  inline AudioSource* New() const { return New(NULL); }

  AudioSource* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioSource& from);
  void MergeFrom(const AudioSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AudioSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool looping = 1;
  bool has_looping() const;
  void clear_looping();
  static const int kLoopingFieldNumber = 1;
  bool looping() const;
  void set_looping(bool value);

  // optional string audio_name = 2;
  bool has_audio_name() const;
  void clear_audio_name();
  static const int kAudioNameFieldNumber = 2;
  const ::std::string& audio_name() const;
  void set_audio_name(const ::std::string& value);
  void set_audio_name(const char* value);
  void set_audio_name(const char* value, size_t size);
  ::std::string* mutable_audio_name();
  ::std::string* release_audio_name();
  void set_allocated_audio_name(::std::string* audio_name);

  // optional bool playing = 3;
  bool has_playing() const;
  void clear_playing();
  static const int kPlayingFieldNumber = 3;
  bool playing() const;
  void set_playing(bool value);

  // optional uint32 volume = 4;
  bool has_volume() const;
  void clear_volume();
  static const int kVolumeFieldNumber = 4;
  ::google::protobuf::uint32 volume() const;
  void set_volume(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:tec.proto.AudioSource)
 private:
  inline void set_has_looping();
  inline void clear_has_looping();
  inline void set_has_audio_name();
  inline void clear_has_audio_name();
  inline void set_has_playing();
  inline void clear_has_playing();
  inline void set_has_volume();
  inline void clear_has_volume();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr audio_name_;
  bool looping_;
  bool playing_;
  ::google::protobuf::uint32 volume_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static AudioSource* default_instance_;
};
// -------------------------------------------------------------------

class Light_Attenuation : public ::google::protobuf::Message {
 public:
  Light_Attenuation();
  virtual ~Light_Attenuation();

  Light_Attenuation(const Light_Attenuation& from);

  inline Light_Attenuation& operator=(const Light_Attenuation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Light_Attenuation& default_instance();

  void Swap(Light_Attenuation* other);

  // implements Message ----------------------------------------------

  inline Light_Attenuation* New() const { return New(NULL); }

  Light_Attenuation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Light_Attenuation& from);
  void MergeFrom(const Light_Attenuation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Light_Attenuation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float constant = 1;
  bool has_constant() const;
  void clear_constant();
  static const int kConstantFieldNumber = 1;
  float constant() const;
  void set_constant(float value);

  // optional float linear = 2;
  bool has_linear() const;
  void clear_linear();
  static const int kLinearFieldNumber = 2;
  float linear() const;
  void set_linear(float value);

  // optional float exponential = 3;
  bool has_exponential() const;
  void clear_exponential();
  static const int kExponentialFieldNumber = 3;
  float exponential() const;
  void set_exponential(float value);

  // @@protoc_insertion_point(class_scope:tec.proto.Light.Attenuation)
 private:
  inline void set_has_constant();
  inline void clear_has_constant();
  inline void set_has_linear();
  inline void clear_has_linear();
  inline void set_has_exponential();
  inline void clear_has_exponential();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float constant_;
  float linear_;
  float exponential_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Light_Attenuation* default_instance_;
};
// -------------------------------------------------------------------

class Light_Direction : public ::google::protobuf::Message {
 public:
  Light_Direction();
  virtual ~Light_Direction();

  Light_Direction(const Light_Direction& from);

  inline Light_Direction& operator=(const Light_Direction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Light_Direction& default_instance();

  void Swap(Light_Direction* other);

  // implements Message ----------------------------------------------

  inline Light_Direction* New() const { return New(NULL); }

  Light_Direction* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Light_Direction& from);
  void MergeFrom(const Light_Direction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Light_Direction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:tec.proto.Light.Direction)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Light_Direction* default_instance_;
};
// -------------------------------------------------------------------

class Light : public ::google::protobuf::Message {
 public:
  Light();
  virtual ~Light();

  Light(const Light& from);

  inline Light& operator=(const Light& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Light& default_instance();

  void Swap(Light* other);

  // implements Message ----------------------------------------------

  inline Light* New() const { return New(NULL); }

  Light* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Light& from);
  void MergeFrom(const Light& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Light* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Light_Attenuation Attenuation;
  typedef Light_Direction Direction;

  // accessors -------------------------------------------------------

  // optional float color_x = 1;
  bool has_color_x() const;
  void clear_color_x();
  static const int kColorXFieldNumber = 1;
  float color_x() const;
  void set_color_x(float value);

  // optional float color_y = 2;
  bool has_color_y() const;
  void clear_color_y();
  static const int kColorYFieldNumber = 2;
  float color_y() const;
  void set_color_y(float value);

  // optional float color_z = 3;
  bool has_color_z() const;
  void clear_color_z();
  static const int kColorZFieldNumber = 3;
  float color_z() const;
  void set_color_z(float value);

  // optional float ambient_intensity = 4;
  bool has_ambient_intensity() const;
  void clear_ambient_intensity();
  static const int kAmbientIntensityFieldNumber = 4;
  float ambient_intensity() const;
  void set_ambient_intensity(float value);

  // optional float diffuse_intensity = 5;
  bool has_diffuse_intensity() const;
  void clear_diffuse_intensity();
  static const int kDiffuseIntensityFieldNumber = 5;
  float diffuse_intensity() const;
  void set_diffuse_intensity(float value);

  // optional .tec.proto.Light.Attenuation attenuation = 6;
  bool has_attenuation() const;
  void clear_attenuation();
  static const int kAttenuationFieldNumber = 6;
  const ::tec::proto::Light_Attenuation& attenuation() const;
  ::tec::proto::Light_Attenuation* mutable_attenuation();
  ::tec::proto::Light_Attenuation* release_attenuation();
  void set_allocated_attenuation(::tec::proto::Light_Attenuation* attenuation);

  // optional float cutoff = 7;
  bool has_cutoff() const;
  void clear_cutoff();
  static const int kCutoffFieldNumber = 7;
  float cutoff() const;
  void set_cutoff(float value);

  // optional .tec.proto.Light.Direction direction = 8;
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 8;
  const ::tec::proto::Light_Direction& direction() const;
  ::tec::proto::Light_Direction* mutable_direction();
  ::tec::proto::Light_Direction* release_direction();
  void set_allocated_direction(::tec::proto::Light_Direction* direction);

  // @@protoc_insertion_point(class_scope:tec.proto.Light)
 private:
  inline void set_has_color_x();
  inline void clear_has_color_x();
  inline void set_has_color_y();
  inline void clear_has_color_y();
  inline void set_has_color_z();
  inline void clear_has_color_z();
  inline void set_has_ambient_intensity();
  inline void clear_has_ambient_intensity();
  inline void set_has_diffuse_intensity();
  inline void clear_has_diffuse_intensity();
  inline void set_has_attenuation();
  inline void clear_has_attenuation();
  inline void set_has_cutoff();
  inline void clear_has_cutoff();
  inline void set_has_direction();
  inline void clear_has_direction();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float color_x_;
  float color_y_;
  float color_z_;
  float ambient_intensity_;
  ::tec::proto::Light_Attenuation* attenuation_;
  float diffuse_intensity_;
  float cutoff_;
  ::tec::proto::Light_Direction* direction_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Light* default_instance_;
};
// -------------------------------------------------------------------

class LuaScript : public ::google::protobuf::Message {
 public:
  LuaScript();
  virtual ~LuaScript();

  LuaScript(const LuaScript& from);

  inline LuaScript& operator=(const LuaScript& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LuaScript& default_instance();

  void Swap(LuaScript* other);

  // implements Message ----------------------------------------------

  inline LuaScript* New() const { return New(NULL); }

  LuaScript* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LuaScript& from);
  void MergeFrom(const LuaScript& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LuaScript* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string script_name = 1;
  bool has_script_name() const;
  void clear_script_name();
  static const int kScriptNameFieldNumber = 1;
  const ::std::string& script_name() const;
  void set_script_name(const ::std::string& value);
  void set_script_name(const char* value);
  void set_script_name(const char* value, size_t size);
  ::std::string* mutable_script_name();
  ::std::string* release_script_name();
  void set_allocated_script_name(::std::string* script_name);

  // @@protoc_insertion_point(class_scope:tec.proto.LuaScript)
 private:
  inline void set_has_script_name();
  inline void clear_has_script_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr script_name_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static LuaScript* default_instance_;
};
// -------------------------------------------------------------------

class VoxelVolumen : public ::google::protobuf::Message {
 public:
  VoxelVolumen();
  virtual ~VoxelVolumen();

  VoxelVolumen(const VoxelVolumen& from);

  inline VoxelVolumen& operator=(const VoxelVolumen& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VoxelVolumen& default_instance();

  void Swap(VoxelVolumen* other);

  // implements Message ----------------------------------------------

  inline VoxelVolumen* New() const { return New(NULL); }

  VoxelVolumen* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VoxelVolumen& from);
  void MergeFrom(const VoxelVolumen& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VoxelVolumen* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float dummy = 1;
  bool has_dummy() const;
  void clear_dummy();
  static const int kDummyFieldNumber = 1;
  float dummy() const;
  void set_dummy(float value);

  // @@protoc_insertion_point(class_scope:tec.proto.VoxelVolumen)
 private:
  inline void set_has_dummy();
  inline void clear_has_dummy();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float dummy_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static VoxelVolumen* default_instance_;
};
// -------------------------------------------------------------------

class ComputerScreen : public ::google::protobuf::Message {
 public:
  ComputerScreen();
  virtual ~ComputerScreen();

  ComputerScreen(const ComputerScreen& from);

  inline ComputerScreen& operator=(const ComputerScreen& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ComputerScreen& default_instance();

  void Swap(ComputerScreen* other);

  // implements Message ----------------------------------------------

  inline ComputerScreen* New() const { return New(NULL); }

  ComputerScreen* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ComputerScreen& from);
  void MergeFrom(const ComputerScreen& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ComputerScreen* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes text_buffer = 1;
  bool has_text_buffer() const;
  void clear_text_buffer();
  static const int kTextBufferFieldNumber = 1;
  const ::std::string& text_buffer() const;
  void set_text_buffer(const ::std::string& value);
  void set_text_buffer(const char* value);
  void set_text_buffer(const void* value, size_t size);
  ::std::string* mutable_text_buffer();
  ::std::string* release_text_buffer();
  void set_allocated_text_buffer(::std::string* text_buffer);

  // required bytes font_buffer = 2;
  bool has_font_buffer() const;
  void clear_font_buffer();
  static const int kFontBufferFieldNumber = 2;
  const ::std::string& font_buffer() const;
  void set_font_buffer(const ::std::string& value);
  void set_font_buffer(const char* value);
  void set_font_buffer(const void* value, size_t size);
  ::std::string* mutable_font_buffer();
  ::std::string* release_font_buffer();
  void set_allocated_font_buffer(::std::string* font_buffer);

  // required uint32 buffer_ptr = 3;
  bool has_buffer_ptr() const;
  void clear_buffer_ptr();
  static const int kBufferPtrFieldNumber = 3;
  ::google::protobuf::uint32 buffer_ptr() const;
  void set_buffer_ptr(::google::protobuf::uint32 value);

  // required uint32 font_ptr = 4;
  bool has_font_ptr() const;
  void clear_font_ptr();
  static const int kFontPtrFieldNumber = 4;
  ::google::protobuf::uint32 font_ptr() const;
  void set_font_ptr(::google::protobuf::uint32 value);

  // required uint32 vsync_msg = 5;
  bool has_vsync_msg() const;
  void clear_vsync_msg();
  static const int kVsyncMsgFieldNumber = 5;
  ::google::protobuf::uint32 vsync_msg() const;
  void set_vsync_msg(::google::protobuf::uint32 value);

  // required uint32 a = 6;
  bool has_a() const;
  void clear_a();
  static const int kAFieldNumber = 6;
  ::google::protobuf::uint32 a() const;
  void set_a(::google::protobuf::uint32 value);

  // required uint32 b = 7;
  bool has_b() const;
  void clear_b();
  static const int kBFieldNumber = 7;
  ::google::protobuf::uint32 b() const;
  void set_b(::google::protobuf::uint32 value);

  // required uint32 d = 8;
  bool has_d() const;
  void clear_d();
  static const int kDFieldNumber = 8;
  ::google::protobuf::uint32 d() const;
  void set_d(::google::protobuf::uint32 value);

  // required uint32 e = 9;
  bool has_e() const;
  void clear_e();
  static const int kEFieldNumber = 9;
  ::google::protobuf::uint32 e() const;
  void set_e(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:tec.proto.ComputerScreen)
 private:
  inline void set_has_text_buffer();
  inline void clear_has_text_buffer();
  inline void set_has_font_buffer();
  inline void clear_has_font_buffer();
  inline void set_has_buffer_ptr();
  inline void clear_has_buffer_ptr();
  inline void set_has_font_ptr();
  inline void clear_has_font_ptr();
  inline void set_has_vsync_msg();
  inline void clear_has_vsync_msg();
  inline void set_has_a();
  inline void clear_has_a();
  inline void set_has_b();
  inline void clear_has_b();
  inline void set_has_d();
  inline void clear_has_d();
  inline void set_has_e();
  inline void clear_has_e();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr text_buffer_;
  ::google::protobuf::internal::ArenaStringPtr font_buffer_;
  ::google::protobuf::uint32 buffer_ptr_;
  ::google::protobuf::uint32 font_ptr_;
  ::google::protobuf::uint32 vsync_msg_;
  ::google::protobuf::uint32 a_;
  ::google::protobuf::uint32 b_;
  ::google::protobuf::uint32 d_;
  ::google::protobuf::uint32 e_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static ComputerScreen* default_instance_;
};
// -------------------------------------------------------------------

class Computer_Device : public ::google::protobuf::Message {
 public:
  Computer_Device();
  virtual ~Computer_Device();

  Computer_Device(const Computer_Device& from);

  inline Computer_Device& operator=(const Computer_Device& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Computer_Device& default_instance();

  enum DeviceCase {
    kComputerScreen = 2,
    DEVICE_NOT_SET = 0,
  };

  void Swap(Computer_Device* other);

  // implements Message ----------------------------------------------

  inline Computer_Device* New() const { return New(NULL); }

  Computer_Device* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Computer_Device& from);
  void MergeFrom(const Computer_Device& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Computer_Device* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 slot = 1;
  bool has_slot() const;
  void clear_slot();
  static const int kSlotFieldNumber = 1;
  ::google::protobuf::uint32 slot() const;
  void set_slot(::google::protobuf::uint32 value);

  // optional .tec.proto.ComputerScreen computerScreen = 2;
  bool has_computerscreen() const;
  void clear_computerscreen();
  static const int kComputerScreenFieldNumber = 2;
  const ::tec::proto::ComputerScreen& computerscreen() const;
  ::tec::proto::ComputerScreen* mutable_computerscreen();
  ::tec::proto::ComputerScreen* release_computerscreen();
  void set_allocated_computerscreen(::tec::proto::ComputerScreen* computerscreen);

  DeviceCase device_case() const;
  // @@protoc_insertion_point(class_scope:tec.proto.Computer.Device)
 private:
  inline void set_has_slot();
  inline void clear_has_slot();
  inline void set_has_computerscreen();

  inline bool has_device() const;
  void clear_device();
  inline void clear_has_device();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 slot_;
  union DeviceUnion {
    DeviceUnion() {}
    ::tec::proto::ComputerScreen* computerscreen_;
  } device_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Computer_Device* default_instance_;
};
// -------------------------------------------------------------------

class Computer_CPU_TR3200 : public ::google::protobuf::Message {
 public:
  Computer_CPU_TR3200();
  virtual ~Computer_CPU_TR3200();

  Computer_CPU_TR3200(const Computer_CPU_TR3200& from);

  inline Computer_CPU_TR3200& operator=(const Computer_CPU_TR3200& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Computer_CPU_TR3200& default_instance();

  void Swap(Computer_CPU_TR3200* other);

  // implements Message ----------------------------------------------

  inline Computer_CPU_TR3200* New() const { return New(NULL); }

  Computer_CPU_TR3200* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Computer_CPU_TR3200& from);
  void MergeFrom(const Computer_CPU_TR3200& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Computer_CPU_TR3200* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 registers = 1;
  int registers_size() const;
  void clear_registers();
  static const int kRegistersFieldNumber = 1;
  ::google::protobuf::uint32 registers(int index) const;
  void set_registers(int index, ::google::protobuf::uint32 value);
  void add_registers(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      registers() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_registers();

  // required uint32 pc = 2;
  bool has_pc() const;
  void clear_pc();
  static const int kPcFieldNumber = 2;
  ::google::protobuf::uint32 pc() const;
  void set_pc(::google::protobuf::uint32 value);

  // required uint32 wait_cycles = 3;
  bool has_wait_cycles() const;
  void clear_wait_cycles();
  static const int kWaitCyclesFieldNumber = 3;
  ::google::protobuf::uint32 wait_cycles() const;
  void set_wait_cycles(::google::protobuf::uint32 value);

  // required uint32 int_msg = 4;
  bool has_int_msg() const;
  void clear_int_msg();
  static const int kIntMsgFieldNumber = 4;
  ::google::protobuf::uint32 int_msg() const;
  void set_int_msg(::google::protobuf::uint32 value);

  // required bool interrupt = 5;
  bool has_interrupt() const;
  void clear_interrupt();
  static const int kInterruptFieldNumber = 5;
  bool interrupt() const;
  void set_interrupt(bool value);

  // required bool step_mode = 6;
  bool has_step_mode() const;
  void clear_step_mode();
  static const int kStepModeFieldNumber = 6;
  bool step_mode() const;
  void set_step_mode(bool value);

  // required bool skiping = 7;
  bool has_skiping() const;
  void clear_skiping();
  static const int kSkipingFieldNumber = 7;
  bool skiping() const;
  void set_skiping(bool value);

  // required bool sleeping = 8;
  bool has_sleeping() const;
  void clear_sleeping();
  static const int kSleepingFieldNumber = 8;
  bool sleeping() const;
  void set_sleeping(bool value);

  // @@protoc_insertion_point(class_scope:tec.proto.Computer.CPU.TR3200)
 private:
  inline void set_has_pc();
  inline void clear_has_pc();
  inline void set_has_wait_cycles();
  inline void clear_has_wait_cycles();
  inline void set_has_int_msg();
  inline void clear_has_int_msg();
  inline void set_has_interrupt();
  inline void clear_has_interrupt();
  inline void set_has_step_mode();
  inline void clear_has_step_mode();
  inline void set_has_skiping();
  inline void clear_has_skiping();
  inline void set_has_sleeping();
  inline void clear_has_sleeping();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > registers_;
  ::google::protobuf::uint32 pc_;
  ::google::protobuf::uint32 wait_cycles_;
  ::google::protobuf::uint32 int_msg_;
  bool interrupt_;
  bool step_mode_;
  bool skiping_;
  bool sleeping_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Computer_CPU_TR3200* default_instance_;
};
// -------------------------------------------------------------------

class Computer_CPU : public ::google::protobuf::Message {
 public:
  Computer_CPU();
  virtual ~Computer_CPU();

  Computer_CPU(const Computer_CPU& from);

  inline Computer_CPU& operator=(const Computer_CPU& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Computer_CPU& default_instance();

  enum CpuCase {
    kTr3200 = 1,
    CPU_NOT_SET = 0,
  };

  void Swap(Computer_CPU* other);

  // implements Message ----------------------------------------------

  inline Computer_CPU* New() const { return New(NULL); }

  Computer_CPU* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Computer_CPU& from);
  void MergeFrom(const Computer_CPU& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Computer_CPU* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Computer_CPU_TR3200 TR3200;

  // accessors -------------------------------------------------------

  // optional .tec.proto.Computer.CPU.TR3200 tr3200 = 1;
  bool has_tr3200() const;
  void clear_tr3200();
  static const int kTr3200FieldNumber = 1;
  const ::tec::proto::Computer_CPU_TR3200& tr3200() const;
  ::tec::proto::Computer_CPU_TR3200* mutable_tr3200();
  ::tec::proto::Computer_CPU_TR3200* release_tr3200();
  void set_allocated_tr3200(::tec::proto::Computer_CPU_TR3200* tr3200);

  CpuCase cpu_case() const;
  // @@protoc_insertion_point(class_scope:tec.proto.Computer.CPU)
 private:
  inline void set_has_tr3200();

  inline bool has_cpu() const;
  void clear_cpu();
  inline void clear_has_cpu();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union CpuUnion {
    CpuUnion() {}
    ::tec::proto::Computer_CPU_TR3200* tr3200_;
  } cpu_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Computer_CPU* default_instance_;
};
// -------------------------------------------------------------------

class Computer : public ::google::protobuf::Message {
 public:
  Computer();
  virtual ~Computer();

  Computer(const Computer& from);

  inline Computer& operator=(const Computer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Computer& default_instance();

  void Swap(Computer* other);

  // implements Message ----------------------------------------------

  inline Computer* New() const { return New(NULL); }

  Computer* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Computer& from);
  void MergeFrom(const Computer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Computer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Computer_Device Device;
  typedef Computer_CPU CPU;

  // accessors -------------------------------------------------------

  // repeated .tec.proto.Computer.Device devices = 1;
  int devices_size() const;
  void clear_devices();
  static const int kDevicesFieldNumber = 1;
  const ::tec::proto::Computer_Device& devices(int index) const;
  ::tec::proto::Computer_Device* mutable_devices(int index);
  ::tec::proto::Computer_Device* add_devices();
  const ::google::protobuf::RepeatedPtrField< ::tec::proto::Computer_Device >&
      devices() const;
  ::google::protobuf::RepeatedPtrField< ::tec::proto::Computer_Device >*
      mutable_devices();

  // required bytes ram = 2;
  bool has_ram() const;
  void clear_ram();
  static const int kRamFieldNumber = 2;
  const ::std::string& ram() const;
  void set_ram(const ::std::string& value);
  void set_ram(const char* value);
  void set_ram(const void* value, size_t size);
  ::std::string* mutable_ram();
  ::std::string* release_ram();
  void set_allocated_ram(::std::string* ram);

  // required .tec.proto.Computer.CPU cpu = 3;
  bool has_cpu() const;
  void clear_cpu();
  static const int kCpuFieldNumber = 3;
  const ::tec::proto::Computer_CPU& cpu() const;
  ::tec::proto::Computer_CPU* mutable_cpu();
  ::tec::proto::Computer_CPU* release_cpu();
  void set_allocated_cpu(::tec::proto::Computer_CPU* cpu);

  // optional string rom_file = 4;
  bool has_rom_file() const;
  void clear_rom_file();
  static const int kRomFileFieldNumber = 4;
  const ::std::string& rom_file() const;
  void set_rom_file(const ::std::string& value);
  void set_rom_file(const char* value);
  void set_rom_file(const char* value, size_t size);
  ::std::string* mutable_rom_file();
  ::std::string* release_rom_file();
  void set_allocated_rom_file(::std::string* rom_file);

  // @@protoc_insertion_point(class_scope:tec.proto.Computer)
 private:
  inline void set_has_ram();
  inline void clear_has_ram();
  inline void set_has_cpu();
  inline void clear_has_cpu();
  inline void set_has_rom_file();
  inline void clear_has_rom_file();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tec::proto::Computer_Device > devices_;
  ::google::protobuf::internal::ArenaStringPtr ram_;
  ::tec::proto::Computer_CPU* cpu_;
  ::google::protobuf::internal::ArenaStringPtr rom_file_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Computer* default_instance_;
};
// -------------------------------------------------------------------

class Component : public ::google::protobuf::Message {
 public:
  Component();
  virtual ~Component();

  Component(const Component& from);

  inline Component& operator=(const Component& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Component& default_instance();

  enum ComponentCase {
    kRenderable = 1,
    kPosition = 2,
    kOrientation = 3,
    kView = 4,
    kAnimation = 5,
    kScale = 6,
    kCollisionBody = 7,
    kVelocity = 8,
    kAudioSource = 9,
    kPointLight = 10,
    kDirectionalLight = 11,
    kSpotLight = 12,
    kVoxelVolume = 13,
    kComputer = 14,
    kLuaScript = 100,
    COMPONENT_NOT_SET = 0,
  };

  void Swap(Component* other);

  // implements Message ----------------------------------------------

  inline Component* New() const { return New(NULL); }

  Component* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Component& from);
  void MergeFrom(const Component& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Component* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .tec.proto.Renderable renderable = 1;
  bool has_renderable() const;
  void clear_renderable();
  static const int kRenderableFieldNumber = 1;
  const ::tec::proto::Renderable& renderable() const;
  ::tec::proto::Renderable* mutable_renderable();
  ::tec::proto::Renderable* release_renderable();
  void set_allocated_renderable(::tec::proto::Renderable* renderable);

  // optional .tec.proto.Position position = 2;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  const ::tec::proto::Position& position() const;
  ::tec::proto::Position* mutable_position();
  ::tec::proto::Position* release_position();
  void set_allocated_position(::tec::proto::Position* position);

  // optional .tec.proto.Orientation orientation = 3;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 3;
  const ::tec::proto::Orientation& orientation() const;
  ::tec::proto::Orientation* mutable_orientation();
  ::tec::proto::Orientation* release_orientation();
  void set_allocated_orientation(::tec::proto::Orientation* orientation);

  // optional .tec.proto.View view = 4;
  bool has_view() const;
  void clear_view();
  static const int kViewFieldNumber = 4;
  const ::tec::proto::View& view() const;
  ::tec::proto::View* mutable_view();
  ::tec::proto::View* release_view();
  void set_allocated_view(::tec::proto::View* view);

  // optional .tec.proto.Animation animation = 5;
  bool has_animation() const;
  void clear_animation();
  static const int kAnimationFieldNumber = 5;
  const ::tec::proto::Animation& animation() const;
  ::tec::proto::Animation* mutable_animation();
  ::tec::proto::Animation* release_animation();
  void set_allocated_animation(::tec::proto::Animation* animation);

  // optional .tec.proto.Scale Scale = 6;
  bool has_scale() const;
  void clear_scale();
  static const int kScaleFieldNumber = 6;
  const ::tec::proto::Scale& scale() const;
  ::tec::proto::Scale* mutable_scale();
  ::tec::proto::Scale* release_scale();
  void set_allocated_scale(::tec::proto::Scale* scale);

  // optional .tec.proto.CollisionBody collision_body = 7;
  bool has_collision_body() const;
  void clear_collision_body();
  static const int kCollisionBodyFieldNumber = 7;
  const ::tec::proto::CollisionBody& collision_body() const;
  ::tec::proto::CollisionBody* mutable_collision_body();
  ::tec::proto::CollisionBody* release_collision_body();
  void set_allocated_collision_body(::tec::proto::CollisionBody* collision_body);

  // optional .tec.proto.Velocity velocity = 8;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 8;
  const ::tec::proto::Velocity& velocity() const;
  ::tec::proto::Velocity* mutable_velocity();
  ::tec::proto::Velocity* release_velocity();
  void set_allocated_velocity(::tec::proto::Velocity* velocity);

  // optional .tec.proto.AudioSource audio_source = 9;
  bool has_audio_source() const;
  void clear_audio_source();
  static const int kAudioSourceFieldNumber = 9;
  const ::tec::proto::AudioSource& audio_source() const;
  ::tec::proto::AudioSource* mutable_audio_source();
  ::tec::proto::AudioSource* release_audio_source();
  void set_allocated_audio_source(::tec::proto::AudioSource* audio_source);

  // optional .tec.proto.Light pointLight = 10;
  bool has_pointlight() const;
  void clear_pointlight();
  static const int kPointLightFieldNumber = 10;
  const ::tec::proto::Light& pointlight() const;
  ::tec::proto::Light* mutable_pointlight();
  ::tec::proto::Light* release_pointlight();
  void set_allocated_pointlight(::tec::proto::Light* pointlight);

  // optional .tec.proto.Light directionalLight = 11;
  bool has_directionallight() const;
  void clear_directionallight();
  static const int kDirectionalLightFieldNumber = 11;
  const ::tec::proto::Light& directionallight() const;
  ::tec::proto::Light* mutable_directionallight();
  ::tec::proto::Light* release_directionallight();
  void set_allocated_directionallight(::tec::proto::Light* directionallight);

  // optional .tec.proto.Light spotLight = 12;
  bool has_spotlight() const;
  void clear_spotlight();
  static const int kSpotLightFieldNumber = 12;
  const ::tec::proto::Light& spotlight() const;
  ::tec::proto::Light* mutable_spotlight();
  ::tec::proto::Light* release_spotlight();
  void set_allocated_spotlight(::tec::proto::Light* spotlight);

  // optional .tec.proto.VoxelVolumen voxelVolume = 13;
  bool has_voxelvolume() const;
  void clear_voxelvolume();
  static const int kVoxelVolumeFieldNumber = 13;
  const ::tec::proto::VoxelVolumen& voxelvolume() const;
  ::tec::proto::VoxelVolumen* mutable_voxelvolume();
  ::tec::proto::VoxelVolumen* release_voxelvolume();
  void set_allocated_voxelvolume(::tec::proto::VoxelVolumen* voxelvolume);

  // optional .tec.proto.Computer computer = 14;
  bool has_computer() const;
  void clear_computer();
  static const int kComputerFieldNumber = 14;
  const ::tec::proto::Computer& computer() const;
  ::tec::proto::Computer* mutable_computer();
  ::tec::proto::Computer* release_computer();
  void set_allocated_computer(::tec::proto::Computer* computer);

  // optional .tec.proto.LuaScript luaScript = 100;
  bool has_luascript() const;
  void clear_luascript();
  static const int kLuaScriptFieldNumber = 100;
  const ::tec::proto::LuaScript& luascript() const;
  ::tec::proto::LuaScript* mutable_luascript();
  ::tec::proto::LuaScript* release_luascript();
  void set_allocated_luascript(::tec::proto::LuaScript* luascript);

  ComponentCase component_case() const;
  // @@protoc_insertion_point(class_scope:tec.proto.Component)
 private:
  inline void set_has_renderable();
  inline void set_has_position();
  inline void set_has_orientation();
  inline void set_has_view();
  inline void set_has_animation();
  inline void set_has_scale();
  inline void set_has_collision_body();
  inline void set_has_velocity();
  inline void set_has_audio_source();
  inline void set_has_pointlight();
  inline void set_has_directionallight();
  inline void set_has_spotlight();
  inline void set_has_voxelvolume();
  inline void set_has_computer();
  inline void set_has_luascript();

  inline bool has_component() const;
  void clear_component();
  inline void clear_has_component();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union ComponentUnion {
    ComponentUnion() {}
    ::tec::proto::Renderable* renderable_;
    ::tec::proto::Position* position_;
    ::tec::proto::Orientation* orientation_;
    ::tec::proto::View* view_;
    ::tec::proto::Animation* animation_;
    ::tec::proto::Scale* scale_;
    ::tec::proto::CollisionBody* collision_body_;
    ::tec::proto::Velocity* velocity_;
    ::tec::proto::AudioSource* audio_source_;
    ::tec::proto::Light* pointlight_;
    ::tec::proto::Light* directionallight_;
    ::tec::proto::Light* spotlight_;
    ::tec::proto::VoxelVolumen* voxelvolume_;
    ::tec::proto::Computer* computer_;
    ::tec::proto::LuaScript* luascript_;
  } component_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Component* default_instance_;
};
// -------------------------------------------------------------------

class Entity : public ::google::protobuf::Message {
 public:
  Entity();
  virtual ~Entity();

  Entity(const Entity& from);

  inline Entity& operator=(const Entity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Entity& default_instance();

  void Swap(Entity* other);

  // implements Message ----------------------------------------------

  inline Entity* New() const { return New(NULL); }

  Entity* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Entity& from);
  void MergeFrom(const Entity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Entity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // repeated .tec.proto.Component components = 2;
  int components_size() const;
  void clear_components();
  static const int kComponentsFieldNumber = 2;
  const ::tec::proto::Component& components(int index) const;
  ::tec::proto::Component* mutable_components(int index);
  ::tec::proto::Component* add_components();
  const ::google::protobuf::RepeatedPtrField< ::tec::proto::Component >&
      components() const;
  ::google::protobuf::RepeatedPtrField< ::tec::proto::Component >*
      mutable_components();

  // @@protoc_insertion_point(class_scope:tec.proto.Entity)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::RepeatedPtrField< ::tec::proto::Component > components_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Entity* default_instance_;
};
// -------------------------------------------------------------------

class EntityFileList : public ::google::protobuf::Message {
 public:
  EntityFileList();
  virtual ~EntityFileList();

  EntityFileList(const EntityFileList& from);

  inline EntityFileList& operator=(const EntityFileList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityFileList& default_instance();

  void Swap(EntityFileList* other);

  // implements Message ----------------------------------------------

  inline EntityFileList* New() const { return New(NULL); }

  EntityFileList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EntityFileList& from);
  void MergeFrom(const EntityFileList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EntityFileList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string entity_file_list = 1;
  int entity_file_list_size() const;
  void clear_entity_file_list();
  static const int kEntityFileListFieldNumber = 1;
  const ::std::string& entity_file_list(int index) const;
  ::std::string* mutable_entity_file_list(int index);
  void set_entity_file_list(int index, const ::std::string& value);
  void set_entity_file_list(int index, const char* value);
  void set_entity_file_list(int index, const char* value, size_t size);
  ::std::string* add_entity_file_list();
  void add_entity_file_list(const ::std::string& value);
  void add_entity_file_list(const char* value);
  void add_entity_file_list(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& entity_file_list() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_entity_file_list();

  // @@protoc_insertion_point(class_scope:tec.proto.EntityFileList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> entity_file_list_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static EntityFileList* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Renderable

// optional string shader_name = 1;
inline bool Renderable::has_shader_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Renderable::set_has_shader_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Renderable::clear_has_shader_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Renderable::clear_shader_name() {
  shader_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_shader_name();
}
inline const ::std::string& Renderable::shader_name() const {
  // @@protoc_insertion_point(field_get:tec.proto.Renderable.shader_name)
  return shader_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Renderable::set_shader_name(const ::std::string& value) {
  set_has_shader_name();
  shader_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tec.proto.Renderable.shader_name)
}
inline void Renderable::set_shader_name(const char* value) {
  set_has_shader_name();
  shader_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tec.proto.Renderable.shader_name)
}
inline void Renderable::set_shader_name(const char* value, size_t size) {
  set_has_shader_name();
  shader_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tec.proto.Renderable.shader_name)
}
inline ::std::string* Renderable::mutable_shader_name() {
  set_has_shader_name();
  // @@protoc_insertion_point(field_mutable:tec.proto.Renderable.shader_name)
  return shader_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Renderable::release_shader_name() {
  clear_has_shader_name();
  return shader_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Renderable::set_allocated_shader_name(::std::string* shader_name) {
  if (shader_name != NULL) {
    set_has_shader_name();
  } else {
    clear_has_shader_name();
  }
  shader_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), shader_name);
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Renderable.shader_name)
}

// optional string mesh_name = 2;
inline bool Renderable::has_mesh_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Renderable::set_has_mesh_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Renderable::clear_has_mesh_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Renderable::clear_mesh_name() {
  mesh_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mesh_name();
}
inline const ::std::string& Renderable::mesh_name() const {
  // @@protoc_insertion_point(field_get:tec.proto.Renderable.mesh_name)
  return mesh_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Renderable::set_mesh_name(const ::std::string& value) {
  set_has_mesh_name();
  mesh_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tec.proto.Renderable.mesh_name)
}
inline void Renderable::set_mesh_name(const char* value) {
  set_has_mesh_name();
  mesh_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tec.proto.Renderable.mesh_name)
}
inline void Renderable::set_mesh_name(const char* value, size_t size) {
  set_has_mesh_name();
  mesh_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tec.proto.Renderable.mesh_name)
}
inline ::std::string* Renderable::mutable_mesh_name() {
  set_has_mesh_name();
  // @@protoc_insertion_point(field_mutable:tec.proto.Renderable.mesh_name)
  return mesh_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Renderable::release_mesh_name() {
  clear_has_mesh_name();
  return mesh_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Renderable::set_allocated_mesh_name(::std::string* mesh_name) {
  if (mesh_name != NULL) {
    set_has_mesh_name();
  } else {
    clear_has_mesh_name();
  }
  mesh_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mesh_name);
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Renderable.mesh_name)
}

// optional bool hidden = 3;
inline bool Renderable::has_hidden() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Renderable::set_has_hidden() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Renderable::clear_has_hidden() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Renderable::clear_hidden() {
  hidden_ = false;
  clear_has_hidden();
}
inline bool Renderable::hidden() const {
  // @@protoc_insertion_point(field_get:tec.proto.Renderable.hidden)
  return hidden_;
}
inline void Renderable::set_hidden(bool value) {
  set_has_hidden();
  hidden_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Renderable.hidden)
}

// -------------------------------------------------------------------

// Position_CenterOffset

// optional float x = 1;
inline bool Position_CenterOffset::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Position_CenterOffset::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Position_CenterOffset::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Position_CenterOffset::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Position_CenterOffset::x() const {
  // @@protoc_insertion_point(field_get:tec.proto.Position.CenterOffset.x)
  return x_;
}
inline void Position_CenterOffset::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Position.CenterOffset.x)
}

// optional float y = 2;
inline bool Position_CenterOffset::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Position_CenterOffset::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Position_CenterOffset::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Position_CenterOffset::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Position_CenterOffset::y() const {
  // @@protoc_insertion_point(field_get:tec.proto.Position.CenterOffset.y)
  return y_;
}
inline void Position_CenterOffset::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Position.CenterOffset.y)
}

// optional float z = 3;
inline bool Position_CenterOffset::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Position_CenterOffset::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Position_CenterOffset::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Position_CenterOffset::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Position_CenterOffset::z() const {
  // @@protoc_insertion_point(field_get:tec.proto.Position.CenterOffset.z)
  return z_;
}
inline void Position_CenterOffset::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Position.CenterOffset.z)
}

// -------------------------------------------------------------------

// Position

// optional float x = 1;
inline bool Position::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Position::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Position::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Position::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Position::x() const {
  // @@protoc_insertion_point(field_get:tec.proto.Position.x)
  return x_;
}
inline void Position::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Position.x)
}

// optional float y = 2;
inline bool Position::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Position::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Position::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Position::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Position::y() const {
  // @@protoc_insertion_point(field_get:tec.proto.Position.y)
  return y_;
}
inline void Position::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Position.y)
}

// optional float z = 3;
inline bool Position::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Position::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Position::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Position::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Position::z() const {
  // @@protoc_insertion_point(field_get:tec.proto.Position.z)
  return z_;
}
inline void Position::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Position.z)
}

// optional .tec.proto.Position.CenterOffset offset = 4;
inline bool Position::has_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Position::set_has_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Position::clear_has_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Position::clear_offset() {
  if (offset_ != NULL) offset_->::tec::proto::Position_CenterOffset::Clear();
  clear_has_offset();
}
inline const ::tec::proto::Position_CenterOffset& Position::offset() const {
  // @@protoc_insertion_point(field_get:tec.proto.Position.offset)
  return offset_ != NULL ? *offset_ : *default_instance_->offset_;
}
inline ::tec::proto::Position_CenterOffset* Position::mutable_offset() {
  set_has_offset();
  if (offset_ == NULL) {
    offset_ = new ::tec::proto::Position_CenterOffset;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Position.offset)
  return offset_;
}
inline ::tec::proto::Position_CenterOffset* Position::release_offset() {
  clear_has_offset();
  ::tec::proto::Position_CenterOffset* temp = offset_;
  offset_ = NULL;
  return temp;
}
inline void Position::set_allocated_offset(::tec::proto::Position_CenterOffset* offset) {
  delete offset_;
  offset_ = offset;
  if (offset) {
    set_has_offset();
  } else {
    clear_has_offset();
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Position.offset)
}

// -------------------------------------------------------------------

// Orientation_RotationOffset

// required float x = 1;
inline bool Orientation_RotationOffset::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Orientation_RotationOffset::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Orientation_RotationOffset::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Orientation_RotationOffset::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Orientation_RotationOffset::x() const {
  // @@protoc_insertion_point(field_get:tec.proto.Orientation.RotationOffset.x)
  return x_;
}
inline void Orientation_RotationOffset::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Orientation.RotationOffset.x)
}

// required float y = 2;
inline bool Orientation_RotationOffset::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Orientation_RotationOffset::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Orientation_RotationOffset::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Orientation_RotationOffset::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Orientation_RotationOffset::y() const {
  // @@protoc_insertion_point(field_get:tec.proto.Orientation.RotationOffset.y)
  return y_;
}
inline void Orientation_RotationOffset::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Orientation.RotationOffset.y)
}

// required float z = 3;
inline bool Orientation_RotationOffset::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Orientation_RotationOffset::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Orientation_RotationOffset::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Orientation_RotationOffset::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Orientation_RotationOffset::z() const {
  // @@protoc_insertion_point(field_get:tec.proto.Orientation.RotationOffset.z)
  return z_;
}
inline void Orientation_RotationOffset::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Orientation.RotationOffset.z)
}

// -------------------------------------------------------------------

// Orientation

// required float x = 1;
inline bool Orientation::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Orientation::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Orientation::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Orientation::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Orientation::x() const {
  // @@protoc_insertion_point(field_get:tec.proto.Orientation.x)
  return x_;
}
inline void Orientation::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Orientation.x)
}

// required float y = 2;
inline bool Orientation::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Orientation::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Orientation::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Orientation::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Orientation::y() const {
  // @@protoc_insertion_point(field_get:tec.proto.Orientation.y)
  return y_;
}
inline void Orientation::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Orientation.y)
}

// required float z = 3;
inline bool Orientation::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Orientation::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Orientation::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Orientation::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Orientation::z() const {
  // @@protoc_insertion_point(field_get:tec.proto.Orientation.z)
  return z_;
}
inline void Orientation::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Orientation.z)
}

// required float w = 4;
inline bool Orientation::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Orientation::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Orientation::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Orientation::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline float Orientation::w() const {
  // @@protoc_insertion_point(field_get:tec.proto.Orientation.w)
  return w_;
}
inline void Orientation::set_w(float value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Orientation.w)
}

// optional .tec.proto.Orientation.RotationOffset offset = 5;
inline bool Orientation::has_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Orientation::set_has_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Orientation::clear_has_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Orientation::clear_offset() {
  if (offset_ != NULL) offset_->::tec::proto::Orientation_RotationOffset::Clear();
  clear_has_offset();
}
inline const ::tec::proto::Orientation_RotationOffset& Orientation::offset() const {
  // @@protoc_insertion_point(field_get:tec.proto.Orientation.offset)
  return offset_ != NULL ? *offset_ : *default_instance_->offset_;
}
inline ::tec::proto::Orientation_RotationOffset* Orientation::mutable_offset() {
  set_has_offset();
  if (offset_ == NULL) {
    offset_ = new ::tec::proto::Orientation_RotationOffset;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Orientation.offset)
  return offset_;
}
inline ::tec::proto::Orientation_RotationOffset* Orientation::release_offset() {
  clear_has_offset();
  ::tec::proto::Orientation_RotationOffset* temp = offset_;
  offset_ = NULL;
  return temp;
}
inline void Orientation::set_allocated_offset(::tec::proto::Orientation_RotationOffset* offset) {
  delete offset_;
  offset_ = offset;
  if (offset) {
    set_has_offset();
  } else {
    clear_has_offset();
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Orientation.offset)
}

// -------------------------------------------------------------------

// View

// optional bool active = 1;
inline bool View::has_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void View::set_has_active() {
  _has_bits_[0] |= 0x00000001u;
}
inline void View::clear_has_active() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void View::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool View::active() const {
  // @@protoc_insertion_point(field_get:tec.proto.View.active)
  return active_;
}
inline void View::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.View.active)
}

// -------------------------------------------------------------------

// Animation

// optional string animation_name = 1;
inline bool Animation::has_animation_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Animation::set_has_animation_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Animation::clear_has_animation_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Animation::clear_animation_name() {
  animation_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_animation_name();
}
inline const ::std::string& Animation::animation_name() const {
  // @@protoc_insertion_point(field_get:tec.proto.Animation.animation_name)
  return animation_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Animation::set_animation_name(const ::std::string& value) {
  set_has_animation_name();
  animation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tec.proto.Animation.animation_name)
}
inline void Animation::set_animation_name(const char* value) {
  set_has_animation_name();
  animation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tec.proto.Animation.animation_name)
}
inline void Animation::set_animation_name(const char* value, size_t size) {
  set_has_animation_name();
  animation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tec.proto.Animation.animation_name)
}
inline ::std::string* Animation::mutable_animation_name() {
  set_has_animation_name();
  // @@protoc_insertion_point(field_mutable:tec.proto.Animation.animation_name)
  return animation_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Animation::release_animation_name() {
  clear_has_animation_name();
  return animation_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Animation::set_allocated_animation_name(::std::string* animation_name) {
  if (animation_name != NULL) {
    set_has_animation_name();
  } else {
    clear_has_animation_name();
  }
  animation_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), animation_name);
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Animation.animation_name)
}

// -------------------------------------------------------------------

// Scale

// optional float x = 1;
inline bool Scale::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Scale::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Scale::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Scale::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Scale::x() const {
  // @@protoc_insertion_point(field_get:tec.proto.Scale.x)
  return x_;
}
inline void Scale::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Scale.x)
}

// optional float y = 2;
inline bool Scale::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Scale::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Scale::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Scale::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Scale::y() const {
  // @@protoc_insertion_point(field_get:tec.proto.Scale.y)
  return y_;
}
inline void Scale::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Scale.y)
}

// optional float z = 3;
inline bool Scale::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Scale::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Scale::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Scale::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Scale::z() const {
  // @@protoc_insertion_point(field_get:tec.proto.Scale.z)
  return z_;
}
inline void Scale::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Scale.z)
}

// -------------------------------------------------------------------

// CollisionBody_Box

// required float x_extent = 1;
inline bool CollisionBody_Box::has_x_extent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CollisionBody_Box::set_has_x_extent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CollisionBody_Box::clear_has_x_extent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CollisionBody_Box::clear_x_extent() {
  x_extent_ = 0;
  clear_has_x_extent();
}
inline float CollisionBody_Box::x_extent() const {
  // @@protoc_insertion_point(field_get:tec.proto.CollisionBody.Box.x_extent)
  return x_extent_;
}
inline void CollisionBody_Box::set_x_extent(float value) {
  set_has_x_extent();
  x_extent_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.CollisionBody.Box.x_extent)
}

// required float y_extent = 2;
inline bool CollisionBody_Box::has_y_extent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CollisionBody_Box::set_has_y_extent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CollisionBody_Box::clear_has_y_extent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CollisionBody_Box::clear_y_extent() {
  y_extent_ = 0;
  clear_has_y_extent();
}
inline float CollisionBody_Box::y_extent() const {
  // @@protoc_insertion_point(field_get:tec.proto.CollisionBody.Box.y_extent)
  return y_extent_;
}
inline void CollisionBody_Box::set_y_extent(float value) {
  set_has_y_extent();
  y_extent_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.CollisionBody.Box.y_extent)
}

// required float z_extent = 3;
inline bool CollisionBody_Box::has_z_extent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CollisionBody_Box::set_has_z_extent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CollisionBody_Box::clear_has_z_extent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CollisionBody_Box::clear_z_extent() {
  z_extent_ = 0;
  clear_has_z_extent();
}
inline float CollisionBody_Box::z_extent() const {
  // @@protoc_insertion_point(field_get:tec.proto.CollisionBody.Box.z_extent)
  return z_extent_;
}
inline void CollisionBody_Box::set_z_extent(float value) {
  set_has_z_extent();
  z_extent_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.CollisionBody.Box.z_extent)
}

// -------------------------------------------------------------------

// CollisionBody_Sphere

// required float radius = 1;
inline bool CollisionBody_Sphere::has_radius() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CollisionBody_Sphere::set_has_radius() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CollisionBody_Sphere::clear_has_radius() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CollisionBody_Sphere::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float CollisionBody_Sphere::radius() const {
  // @@protoc_insertion_point(field_get:tec.proto.CollisionBody.Sphere.radius)
  return radius_;
}
inline void CollisionBody_Sphere::set_radius(float value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.CollisionBody.Sphere.radius)
}

// -------------------------------------------------------------------

// CollisionBody_Capsule

// required float radius = 1;
inline bool CollisionBody_Capsule::has_radius() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CollisionBody_Capsule::set_has_radius() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CollisionBody_Capsule::clear_has_radius() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CollisionBody_Capsule::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float CollisionBody_Capsule::radius() const {
  // @@protoc_insertion_point(field_get:tec.proto.CollisionBody.Capsule.radius)
  return radius_;
}
inline void CollisionBody_Capsule::set_radius(float value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.CollisionBody.Capsule.radius)
}

// required float height = 2;
inline bool CollisionBody_Capsule::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CollisionBody_Capsule::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CollisionBody_Capsule::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CollisionBody_Capsule::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline float CollisionBody_Capsule::height() const {
  // @@protoc_insertion_point(field_get:tec.proto.CollisionBody.Capsule.height)
  return height_;
}
inline void CollisionBody_Capsule::set_height(float value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.CollisionBody.Capsule.height)
}

// -------------------------------------------------------------------

// CollisionBody

// optional bool disable_deactivation = 1;
inline bool CollisionBody::has_disable_deactivation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CollisionBody::set_has_disable_deactivation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CollisionBody::clear_has_disable_deactivation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CollisionBody::clear_disable_deactivation() {
  disable_deactivation_ = false;
  clear_has_disable_deactivation();
}
inline bool CollisionBody::disable_deactivation() const {
  // @@protoc_insertion_point(field_get:tec.proto.CollisionBody.disable_deactivation)
  return disable_deactivation_;
}
inline void CollisionBody::set_disable_deactivation(bool value) {
  set_has_disable_deactivation();
  disable_deactivation_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.CollisionBody.disable_deactivation)
}

// optional bool disable_rotation = 2;
inline bool CollisionBody::has_disable_rotation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CollisionBody::set_has_disable_rotation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CollisionBody::clear_has_disable_rotation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CollisionBody::clear_disable_rotation() {
  disable_rotation_ = false;
  clear_has_disable_rotation();
}
inline bool CollisionBody::disable_rotation() const {
  // @@protoc_insertion_point(field_get:tec.proto.CollisionBody.disable_rotation)
  return disable_rotation_;
}
inline void CollisionBody::set_disable_rotation(bool value) {
  set_has_disable_rotation();
  disable_rotation_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.CollisionBody.disable_rotation)
}

// optional .tec.proto.CollisionBody.Box box = 3;
inline bool CollisionBody::has_box() const {
  return shape_case() == kBox;
}
inline void CollisionBody::set_has_box() {
  _oneof_case_[0] = kBox;
}
inline void CollisionBody::clear_box() {
  if (has_box()) {
    delete shape_.box_;
    clear_has_shape();
  }
}
inline const ::tec::proto::CollisionBody_Box& CollisionBody::box() const {
  // @@protoc_insertion_point(field_get:tec.proto.CollisionBody.box)
  return has_box() ? *shape_.box_
                      : ::tec::proto::CollisionBody_Box::default_instance();
}
inline ::tec::proto::CollisionBody_Box* CollisionBody::mutable_box() {
  if (!has_box()) {
    clear_shape();
    set_has_box();
    shape_.box_ = new ::tec::proto::CollisionBody_Box;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.CollisionBody.box)
  return shape_.box_;
}
inline ::tec::proto::CollisionBody_Box* CollisionBody::release_box() {
  if (has_box()) {
    clear_has_shape();
    ::tec::proto::CollisionBody_Box* temp = shape_.box_;
    shape_.box_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CollisionBody::set_allocated_box(::tec::proto::CollisionBody_Box* box) {
  clear_shape();
  if (box) {
    set_has_box();
    shape_.box_ = box;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.CollisionBody.box)
}

// optional .tec.proto.CollisionBody.Sphere sphere = 4;
inline bool CollisionBody::has_sphere() const {
  return shape_case() == kSphere;
}
inline void CollisionBody::set_has_sphere() {
  _oneof_case_[0] = kSphere;
}
inline void CollisionBody::clear_sphere() {
  if (has_sphere()) {
    delete shape_.sphere_;
    clear_has_shape();
  }
}
inline const ::tec::proto::CollisionBody_Sphere& CollisionBody::sphere() const {
  // @@protoc_insertion_point(field_get:tec.proto.CollisionBody.sphere)
  return has_sphere() ? *shape_.sphere_
                      : ::tec::proto::CollisionBody_Sphere::default_instance();
}
inline ::tec::proto::CollisionBody_Sphere* CollisionBody::mutable_sphere() {
  if (!has_sphere()) {
    clear_shape();
    set_has_sphere();
    shape_.sphere_ = new ::tec::proto::CollisionBody_Sphere;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.CollisionBody.sphere)
  return shape_.sphere_;
}
inline ::tec::proto::CollisionBody_Sphere* CollisionBody::release_sphere() {
  if (has_sphere()) {
    clear_has_shape();
    ::tec::proto::CollisionBody_Sphere* temp = shape_.sphere_;
    shape_.sphere_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CollisionBody::set_allocated_sphere(::tec::proto::CollisionBody_Sphere* sphere) {
  clear_shape();
  if (sphere) {
    set_has_sphere();
    shape_.sphere_ = sphere;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.CollisionBody.sphere)
}

// optional .tec.proto.CollisionBody.Capsule capsule = 5;
inline bool CollisionBody::has_capsule() const {
  return shape_case() == kCapsule;
}
inline void CollisionBody::set_has_capsule() {
  _oneof_case_[0] = kCapsule;
}
inline void CollisionBody::clear_capsule() {
  if (has_capsule()) {
    delete shape_.capsule_;
    clear_has_shape();
  }
}
inline const ::tec::proto::CollisionBody_Capsule& CollisionBody::capsule() const {
  // @@protoc_insertion_point(field_get:tec.proto.CollisionBody.capsule)
  return has_capsule() ? *shape_.capsule_
                      : ::tec::proto::CollisionBody_Capsule::default_instance();
}
inline ::tec::proto::CollisionBody_Capsule* CollisionBody::mutable_capsule() {
  if (!has_capsule()) {
    clear_shape();
    set_has_capsule();
    shape_.capsule_ = new ::tec::proto::CollisionBody_Capsule;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.CollisionBody.capsule)
  return shape_.capsule_;
}
inline ::tec::proto::CollisionBody_Capsule* CollisionBody::release_capsule() {
  if (has_capsule()) {
    clear_has_shape();
    ::tec::proto::CollisionBody_Capsule* temp = shape_.capsule_;
    shape_.capsule_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CollisionBody::set_allocated_capsule(::tec::proto::CollisionBody_Capsule* capsule) {
  clear_shape();
  if (capsule) {
    set_has_capsule();
    shape_.capsule_ = capsule;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.CollisionBody.capsule)
}

// optional float mass = 6;
inline bool CollisionBody::has_mass() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CollisionBody::set_has_mass() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CollisionBody::clear_has_mass() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CollisionBody::clear_mass() {
  mass_ = 0;
  clear_has_mass();
}
inline float CollisionBody::mass() const {
  // @@protoc_insertion_point(field_get:tec.proto.CollisionBody.mass)
  return mass_;
}
inline void CollisionBody::set_mass(float value) {
  set_has_mass();
  mass_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.CollisionBody.mass)
}

inline bool CollisionBody::has_shape() const {
  return shape_case() != SHAPE_NOT_SET;
}
inline void CollisionBody::clear_has_shape() {
  _oneof_case_[0] = SHAPE_NOT_SET;
}
inline CollisionBody::ShapeCase CollisionBody::shape_case() const {
  return CollisionBody::ShapeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Velocity

// optional float linear_x = 1;
inline bool Velocity::has_linear_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Velocity::set_has_linear_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Velocity::clear_has_linear_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Velocity::clear_linear_x() {
  linear_x_ = 0;
  clear_has_linear_x();
}
inline float Velocity::linear_x() const {
  // @@protoc_insertion_point(field_get:tec.proto.Velocity.linear_x)
  return linear_x_;
}
inline void Velocity::set_linear_x(float value) {
  set_has_linear_x();
  linear_x_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Velocity.linear_x)
}

// optional float linear_y = 2;
inline bool Velocity::has_linear_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Velocity::set_has_linear_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Velocity::clear_has_linear_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Velocity::clear_linear_y() {
  linear_y_ = 0;
  clear_has_linear_y();
}
inline float Velocity::linear_y() const {
  // @@protoc_insertion_point(field_get:tec.proto.Velocity.linear_y)
  return linear_y_;
}
inline void Velocity::set_linear_y(float value) {
  set_has_linear_y();
  linear_y_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Velocity.linear_y)
}

// optional float linear_z = 3;
inline bool Velocity::has_linear_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Velocity::set_has_linear_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Velocity::clear_has_linear_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Velocity::clear_linear_z() {
  linear_z_ = 0;
  clear_has_linear_z();
}
inline float Velocity::linear_z() const {
  // @@protoc_insertion_point(field_get:tec.proto.Velocity.linear_z)
  return linear_z_;
}
inline void Velocity::set_linear_z(float value) {
  set_has_linear_z();
  linear_z_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Velocity.linear_z)
}

// optional float angular_x = 4;
inline bool Velocity::has_angular_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Velocity::set_has_angular_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Velocity::clear_has_angular_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Velocity::clear_angular_x() {
  angular_x_ = 0;
  clear_has_angular_x();
}
inline float Velocity::angular_x() const {
  // @@protoc_insertion_point(field_get:tec.proto.Velocity.angular_x)
  return angular_x_;
}
inline void Velocity::set_angular_x(float value) {
  set_has_angular_x();
  angular_x_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Velocity.angular_x)
}

// optional float angular_y = 5;
inline bool Velocity::has_angular_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Velocity::set_has_angular_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Velocity::clear_has_angular_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Velocity::clear_angular_y() {
  angular_y_ = 0;
  clear_has_angular_y();
}
inline float Velocity::angular_y() const {
  // @@protoc_insertion_point(field_get:tec.proto.Velocity.angular_y)
  return angular_y_;
}
inline void Velocity::set_angular_y(float value) {
  set_has_angular_y();
  angular_y_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Velocity.angular_y)
}

// optional float angular_z = 6;
inline bool Velocity::has_angular_z() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Velocity::set_has_angular_z() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Velocity::clear_has_angular_z() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Velocity::clear_angular_z() {
  angular_z_ = 0;
  clear_has_angular_z();
}
inline float Velocity::angular_z() const {
  // @@protoc_insertion_point(field_get:tec.proto.Velocity.angular_z)
  return angular_z_;
}
inline void Velocity::set_angular_z(float value) {
  set_has_angular_z();
  angular_z_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Velocity.angular_z)
}

// -------------------------------------------------------------------

// AudioSource

// optional bool looping = 1;
inline bool AudioSource::has_looping() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AudioSource::set_has_looping() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AudioSource::clear_has_looping() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AudioSource::clear_looping() {
  looping_ = false;
  clear_has_looping();
}
inline bool AudioSource::looping() const {
  // @@protoc_insertion_point(field_get:tec.proto.AudioSource.looping)
  return looping_;
}
inline void AudioSource::set_looping(bool value) {
  set_has_looping();
  looping_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.AudioSource.looping)
}

// optional string audio_name = 2;
inline bool AudioSource::has_audio_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AudioSource::set_has_audio_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AudioSource::clear_has_audio_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AudioSource::clear_audio_name() {
  audio_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_audio_name();
}
inline const ::std::string& AudioSource::audio_name() const {
  // @@protoc_insertion_point(field_get:tec.proto.AudioSource.audio_name)
  return audio_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AudioSource::set_audio_name(const ::std::string& value) {
  set_has_audio_name();
  audio_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tec.proto.AudioSource.audio_name)
}
inline void AudioSource::set_audio_name(const char* value) {
  set_has_audio_name();
  audio_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tec.proto.AudioSource.audio_name)
}
inline void AudioSource::set_audio_name(const char* value, size_t size) {
  set_has_audio_name();
  audio_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tec.proto.AudioSource.audio_name)
}
inline ::std::string* AudioSource::mutable_audio_name() {
  set_has_audio_name();
  // @@protoc_insertion_point(field_mutable:tec.proto.AudioSource.audio_name)
  return audio_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AudioSource::release_audio_name() {
  clear_has_audio_name();
  return audio_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AudioSource::set_allocated_audio_name(::std::string* audio_name) {
  if (audio_name != NULL) {
    set_has_audio_name();
  } else {
    clear_has_audio_name();
  }
  audio_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), audio_name);
  // @@protoc_insertion_point(field_set_allocated:tec.proto.AudioSource.audio_name)
}

// optional bool playing = 3;
inline bool AudioSource::has_playing() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AudioSource::set_has_playing() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AudioSource::clear_has_playing() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AudioSource::clear_playing() {
  playing_ = false;
  clear_has_playing();
}
inline bool AudioSource::playing() const {
  // @@protoc_insertion_point(field_get:tec.proto.AudioSource.playing)
  return playing_;
}
inline void AudioSource::set_playing(bool value) {
  set_has_playing();
  playing_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.AudioSource.playing)
}

// optional uint32 volume = 4;
inline bool AudioSource::has_volume() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AudioSource::set_has_volume() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AudioSource::clear_has_volume() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AudioSource::clear_volume() {
  volume_ = 0u;
  clear_has_volume();
}
inline ::google::protobuf::uint32 AudioSource::volume() const {
  // @@protoc_insertion_point(field_get:tec.proto.AudioSource.volume)
  return volume_;
}
inline void AudioSource::set_volume(::google::protobuf::uint32 value) {
  set_has_volume();
  volume_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.AudioSource.volume)
}

// -------------------------------------------------------------------

// Light_Attenuation

// optional float constant = 1;
inline bool Light_Attenuation::has_constant() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Light_Attenuation::set_has_constant() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Light_Attenuation::clear_has_constant() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Light_Attenuation::clear_constant() {
  constant_ = 0;
  clear_has_constant();
}
inline float Light_Attenuation::constant() const {
  // @@protoc_insertion_point(field_get:tec.proto.Light.Attenuation.constant)
  return constant_;
}
inline void Light_Attenuation::set_constant(float value) {
  set_has_constant();
  constant_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Light.Attenuation.constant)
}

// optional float linear = 2;
inline bool Light_Attenuation::has_linear() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Light_Attenuation::set_has_linear() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Light_Attenuation::clear_has_linear() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Light_Attenuation::clear_linear() {
  linear_ = 0;
  clear_has_linear();
}
inline float Light_Attenuation::linear() const {
  // @@protoc_insertion_point(field_get:tec.proto.Light.Attenuation.linear)
  return linear_;
}
inline void Light_Attenuation::set_linear(float value) {
  set_has_linear();
  linear_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Light.Attenuation.linear)
}

// optional float exponential = 3;
inline bool Light_Attenuation::has_exponential() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Light_Attenuation::set_has_exponential() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Light_Attenuation::clear_has_exponential() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Light_Attenuation::clear_exponential() {
  exponential_ = 0;
  clear_has_exponential();
}
inline float Light_Attenuation::exponential() const {
  // @@protoc_insertion_point(field_get:tec.proto.Light.Attenuation.exponential)
  return exponential_;
}
inline void Light_Attenuation::set_exponential(float value) {
  set_has_exponential();
  exponential_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Light.Attenuation.exponential)
}

// -------------------------------------------------------------------

// Light_Direction

// optional float x = 1;
inline bool Light_Direction::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Light_Direction::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Light_Direction::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Light_Direction::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Light_Direction::x() const {
  // @@protoc_insertion_point(field_get:tec.proto.Light.Direction.x)
  return x_;
}
inline void Light_Direction::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Light.Direction.x)
}

// optional float y = 2;
inline bool Light_Direction::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Light_Direction::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Light_Direction::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Light_Direction::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Light_Direction::y() const {
  // @@protoc_insertion_point(field_get:tec.proto.Light.Direction.y)
  return y_;
}
inline void Light_Direction::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Light.Direction.y)
}

// optional float z = 3;
inline bool Light_Direction::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Light_Direction::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Light_Direction::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Light_Direction::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Light_Direction::z() const {
  // @@protoc_insertion_point(field_get:tec.proto.Light.Direction.z)
  return z_;
}
inline void Light_Direction::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Light.Direction.z)
}

// -------------------------------------------------------------------

// Light

// optional float color_x = 1;
inline bool Light::has_color_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Light::set_has_color_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Light::clear_has_color_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Light::clear_color_x() {
  color_x_ = 0;
  clear_has_color_x();
}
inline float Light::color_x() const {
  // @@protoc_insertion_point(field_get:tec.proto.Light.color_x)
  return color_x_;
}
inline void Light::set_color_x(float value) {
  set_has_color_x();
  color_x_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Light.color_x)
}

// optional float color_y = 2;
inline bool Light::has_color_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Light::set_has_color_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Light::clear_has_color_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Light::clear_color_y() {
  color_y_ = 0;
  clear_has_color_y();
}
inline float Light::color_y() const {
  // @@protoc_insertion_point(field_get:tec.proto.Light.color_y)
  return color_y_;
}
inline void Light::set_color_y(float value) {
  set_has_color_y();
  color_y_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Light.color_y)
}

// optional float color_z = 3;
inline bool Light::has_color_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Light::set_has_color_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Light::clear_has_color_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Light::clear_color_z() {
  color_z_ = 0;
  clear_has_color_z();
}
inline float Light::color_z() const {
  // @@protoc_insertion_point(field_get:tec.proto.Light.color_z)
  return color_z_;
}
inline void Light::set_color_z(float value) {
  set_has_color_z();
  color_z_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Light.color_z)
}

// optional float ambient_intensity = 4;
inline bool Light::has_ambient_intensity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Light::set_has_ambient_intensity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Light::clear_has_ambient_intensity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Light::clear_ambient_intensity() {
  ambient_intensity_ = 0;
  clear_has_ambient_intensity();
}
inline float Light::ambient_intensity() const {
  // @@protoc_insertion_point(field_get:tec.proto.Light.ambient_intensity)
  return ambient_intensity_;
}
inline void Light::set_ambient_intensity(float value) {
  set_has_ambient_intensity();
  ambient_intensity_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Light.ambient_intensity)
}

// optional float diffuse_intensity = 5;
inline bool Light::has_diffuse_intensity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Light::set_has_diffuse_intensity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Light::clear_has_diffuse_intensity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Light::clear_diffuse_intensity() {
  diffuse_intensity_ = 0;
  clear_has_diffuse_intensity();
}
inline float Light::diffuse_intensity() const {
  // @@protoc_insertion_point(field_get:tec.proto.Light.diffuse_intensity)
  return diffuse_intensity_;
}
inline void Light::set_diffuse_intensity(float value) {
  set_has_diffuse_intensity();
  diffuse_intensity_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Light.diffuse_intensity)
}

// optional .tec.proto.Light.Attenuation attenuation = 6;
inline bool Light::has_attenuation() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Light::set_has_attenuation() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Light::clear_has_attenuation() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Light::clear_attenuation() {
  if (attenuation_ != NULL) attenuation_->::tec::proto::Light_Attenuation::Clear();
  clear_has_attenuation();
}
inline const ::tec::proto::Light_Attenuation& Light::attenuation() const {
  // @@protoc_insertion_point(field_get:tec.proto.Light.attenuation)
  return attenuation_ != NULL ? *attenuation_ : *default_instance_->attenuation_;
}
inline ::tec::proto::Light_Attenuation* Light::mutable_attenuation() {
  set_has_attenuation();
  if (attenuation_ == NULL) {
    attenuation_ = new ::tec::proto::Light_Attenuation;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Light.attenuation)
  return attenuation_;
}
inline ::tec::proto::Light_Attenuation* Light::release_attenuation() {
  clear_has_attenuation();
  ::tec::proto::Light_Attenuation* temp = attenuation_;
  attenuation_ = NULL;
  return temp;
}
inline void Light::set_allocated_attenuation(::tec::proto::Light_Attenuation* attenuation) {
  delete attenuation_;
  attenuation_ = attenuation;
  if (attenuation) {
    set_has_attenuation();
  } else {
    clear_has_attenuation();
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Light.attenuation)
}

// optional float cutoff = 7;
inline bool Light::has_cutoff() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Light::set_has_cutoff() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Light::clear_has_cutoff() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Light::clear_cutoff() {
  cutoff_ = 0;
  clear_has_cutoff();
}
inline float Light::cutoff() const {
  // @@protoc_insertion_point(field_get:tec.proto.Light.cutoff)
  return cutoff_;
}
inline void Light::set_cutoff(float value) {
  set_has_cutoff();
  cutoff_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Light.cutoff)
}

// optional .tec.proto.Light.Direction direction = 8;
inline bool Light::has_direction() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Light::set_has_direction() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Light::clear_has_direction() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Light::clear_direction() {
  if (direction_ != NULL) direction_->::tec::proto::Light_Direction::Clear();
  clear_has_direction();
}
inline const ::tec::proto::Light_Direction& Light::direction() const {
  // @@protoc_insertion_point(field_get:tec.proto.Light.direction)
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
inline ::tec::proto::Light_Direction* Light::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) {
    direction_ = new ::tec::proto::Light_Direction;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Light.direction)
  return direction_;
}
inline ::tec::proto::Light_Direction* Light::release_direction() {
  clear_has_direction();
  ::tec::proto::Light_Direction* temp = direction_;
  direction_ = NULL;
  return temp;
}
inline void Light::set_allocated_direction(::tec::proto::Light_Direction* direction) {
  delete direction_;
  direction_ = direction;
  if (direction) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Light.direction)
}

// -------------------------------------------------------------------

// LuaScript

// optional string script_name = 1;
inline bool LuaScript::has_script_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LuaScript::set_has_script_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LuaScript::clear_has_script_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LuaScript::clear_script_name() {
  script_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_script_name();
}
inline const ::std::string& LuaScript::script_name() const {
  // @@protoc_insertion_point(field_get:tec.proto.LuaScript.script_name)
  return script_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LuaScript::set_script_name(const ::std::string& value) {
  set_has_script_name();
  script_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tec.proto.LuaScript.script_name)
}
inline void LuaScript::set_script_name(const char* value) {
  set_has_script_name();
  script_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tec.proto.LuaScript.script_name)
}
inline void LuaScript::set_script_name(const char* value, size_t size) {
  set_has_script_name();
  script_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tec.proto.LuaScript.script_name)
}
inline ::std::string* LuaScript::mutable_script_name() {
  set_has_script_name();
  // @@protoc_insertion_point(field_mutable:tec.proto.LuaScript.script_name)
  return script_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LuaScript::release_script_name() {
  clear_has_script_name();
  return script_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LuaScript::set_allocated_script_name(::std::string* script_name) {
  if (script_name != NULL) {
    set_has_script_name();
  } else {
    clear_has_script_name();
  }
  script_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), script_name);
  // @@protoc_insertion_point(field_set_allocated:tec.proto.LuaScript.script_name)
}

// -------------------------------------------------------------------

// VoxelVolumen

// optional float dummy = 1;
inline bool VoxelVolumen::has_dummy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VoxelVolumen::set_has_dummy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VoxelVolumen::clear_has_dummy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VoxelVolumen::clear_dummy() {
  dummy_ = 0;
  clear_has_dummy();
}
inline float VoxelVolumen::dummy() const {
  // @@protoc_insertion_point(field_get:tec.proto.VoxelVolumen.dummy)
  return dummy_;
}
inline void VoxelVolumen::set_dummy(float value) {
  set_has_dummy();
  dummy_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.VoxelVolumen.dummy)
}

// -------------------------------------------------------------------

// ComputerScreen

// required bytes text_buffer = 1;
inline bool ComputerScreen::has_text_buffer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ComputerScreen::set_has_text_buffer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ComputerScreen::clear_has_text_buffer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ComputerScreen::clear_text_buffer() {
  text_buffer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text_buffer();
}
inline const ::std::string& ComputerScreen::text_buffer() const {
  // @@protoc_insertion_point(field_get:tec.proto.ComputerScreen.text_buffer)
  return text_buffer_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComputerScreen::set_text_buffer(const ::std::string& value) {
  set_has_text_buffer();
  text_buffer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tec.proto.ComputerScreen.text_buffer)
}
inline void ComputerScreen::set_text_buffer(const char* value) {
  set_has_text_buffer();
  text_buffer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tec.proto.ComputerScreen.text_buffer)
}
inline void ComputerScreen::set_text_buffer(const void* value, size_t size) {
  set_has_text_buffer();
  text_buffer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tec.proto.ComputerScreen.text_buffer)
}
inline ::std::string* ComputerScreen::mutable_text_buffer() {
  set_has_text_buffer();
  // @@protoc_insertion_point(field_mutable:tec.proto.ComputerScreen.text_buffer)
  return text_buffer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ComputerScreen::release_text_buffer() {
  clear_has_text_buffer();
  return text_buffer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComputerScreen::set_allocated_text_buffer(::std::string* text_buffer) {
  if (text_buffer != NULL) {
    set_has_text_buffer();
  } else {
    clear_has_text_buffer();
  }
  text_buffer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text_buffer);
  // @@protoc_insertion_point(field_set_allocated:tec.proto.ComputerScreen.text_buffer)
}

// required bytes font_buffer = 2;
inline bool ComputerScreen::has_font_buffer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ComputerScreen::set_has_font_buffer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ComputerScreen::clear_has_font_buffer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ComputerScreen::clear_font_buffer() {
  font_buffer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_font_buffer();
}
inline const ::std::string& ComputerScreen::font_buffer() const {
  // @@protoc_insertion_point(field_get:tec.proto.ComputerScreen.font_buffer)
  return font_buffer_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComputerScreen::set_font_buffer(const ::std::string& value) {
  set_has_font_buffer();
  font_buffer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tec.proto.ComputerScreen.font_buffer)
}
inline void ComputerScreen::set_font_buffer(const char* value) {
  set_has_font_buffer();
  font_buffer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tec.proto.ComputerScreen.font_buffer)
}
inline void ComputerScreen::set_font_buffer(const void* value, size_t size) {
  set_has_font_buffer();
  font_buffer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tec.proto.ComputerScreen.font_buffer)
}
inline ::std::string* ComputerScreen::mutable_font_buffer() {
  set_has_font_buffer();
  // @@protoc_insertion_point(field_mutable:tec.proto.ComputerScreen.font_buffer)
  return font_buffer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ComputerScreen::release_font_buffer() {
  clear_has_font_buffer();
  return font_buffer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComputerScreen::set_allocated_font_buffer(::std::string* font_buffer) {
  if (font_buffer != NULL) {
    set_has_font_buffer();
  } else {
    clear_has_font_buffer();
  }
  font_buffer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), font_buffer);
  // @@protoc_insertion_point(field_set_allocated:tec.proto.ComputerScreen.font_buffer)
}

// required uint32 buffer_ptr = 3;
inline bool ComputerScreen::has_buffer_ptr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ComputerScreen::set_has_buffer_ptr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ComputerScreen::clear_has_buffer_ptr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ComputerScreen::clear_buffer_ptr() {
  buffer_ptr_ = 0u;
  clear_has_buffer_ptr();
}
inline ::google::protobuf::uint32 ComputerScreen::buffer_ptr() const {
  // @@protoc_insertion_point(field_get:tec.proto.ComputerScreen.buffer_ptr)
  return buffer_ptr_;
}
inline void ComputerScreen::set_buffer_ptr(::google::protobuf::uint32 value) {
  set_has_buffer_ptr();
  buffer_ptr_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.ComputerScreen.buffer_ptr)
}

// required uint32 font_ptr = 4;
inline bool ComputerScreen::has_font_ptr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ComputerScreen::set_has_font_ptr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ComputerScreen::clear_has_font_ptr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ComputerScreen::clear_font_ptr() {
  font_ptr_ = 0u;
  clear_has_font_ptr();
}
inline ::google::protobuf::uint32 ComputerScreen::font_ptr() const {
  // @@protoc_insertion_point(field_get:tec.proto.ComputerScreen.font_ptr)
  return font_ptr_;
}
inline void ComputerScreen::set_font_ptr(::google::protobuf::uint32 value) {
  set_has_font_ptr();
  font_ptr_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.ComputerScreen.font_ptr)
}

// required uint32 vsync_msg = 5;
inline bool ComputerScreen::has_vsync_msg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ComputerScreen::set_has_vsync_msg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ComputerScreen::clear_has_vsync_msg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ComputerScreen::clear_vsync_msg() {
  vsync_msg_ = 0u;
  clear_has_vsync_msg();
}
inline ::google::protobuf::uint32 ComputerScreen::vsync_msg() const {
  // @@protoc_insertion_point(field_get:tec.proto.ComputerScreen.vsync_msg)
  return vsync_msg_;
}
inline void ComputerScreen::set_vsync_msg(::google::protobuf::uint32 value) {
  set_has_vsync_msg();
  vsync_msg_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.ComputerScreen.vsync_msg)
}

// required uint32 a = 6;
inline bool ComputerScreen::has_a() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ComputerScreen::set_has_a() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ComputerScreen::clear_has_a() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ComputerScreen::clear_a() {
  a_ = 0u;
  clear_has_a();
}
inline ::google::protobuf::uint32 ComputerScreen::a() const {
  // @@protoc_insertion_point(field_get:tec.proto.ComputerScreen.a)
  return a_;
}
inline void ComputerScreen::set_a(::google::protobuf::uint32 value) {
  set_has_a();
  a_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.ComputerScreen.a)
}

// required uint32 b = 7;
inline bool ComputerScreen::has_b() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ComputerScreen::set_has_b() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ComputerScreen::clear_has_b() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ComputerScreen::clear_b() {
  b_ = 0u;
  clear_has_b();
}
inline ::google::protobuf::uint32 ComputerScreen::b() const {
  // @@protoc_insertion_point(field_get:tec.proto.ComputerScreen.b)
  return b_;
}
inline void ComputerScreen::set_b(::google::protobuf::uint32 value) {
  set_has_b();
  b_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.ComputerScreen.b)
}

// required uint32 d = 8;
inline bool ComputerScreen::has_d() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ComputerScreen::set_has_d() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ComputerScreen::clear_has_d() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ComputerScreen::clear_d() {
  d_ = 0u;
  clear_has_d();
}
inline ::google::protobuf::uint32 ComputerScreen::d() const {
  // @@protoc_insertion_point(field_get:tec.proto.ComputerScreen.d)
  return d_;
}
inline void ComputerScreen::set_d(::google::protobuf::uint32 value) {
  set_has_d();
  d_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.ComputerScreen.d)
}

// required uint32 e = 9;
inline bool ComputerScreen::has_e() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ComputerScreen::set_has_e() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ComputerScreen::clear_has_e() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ComputerScreen::clear_e() {
  e_ = 0u;
  clear_has_e();
}
inline ::google::protobuf::uint32 ComputerScreen::e() const {
  // @@protoc_insertion_point(field_get:tec.proto.ComputerScreen.e)
  return e_;
}
inline void ComputerScreen::set_e(::google::protobuf::uint32 value) {
  set_has_e();
  e_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.ComputerScreen.e)
}

// -------------------------------------------------------------------

// Computer_Device

// required uint32 slot = 1;
inline bool Computer_Device::has_slot() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Computer_Device::set_has_slot() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Computer_Device::clear_has_slot() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Computer_Device::clear_slot() {
  slot_ = 0u;
  clear_has_slot();
}
inline ::google::protobuf::uint32 Computer_Device::slot() const {
  // @@protoc_insertion_point(field_get:tec.proto.Computer.Device.slot)
  return slot_;
}
inline void Computer_Device::set_slot(::google::protobuf::uint32 value) {
  set_has_slot();
  slot_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Computer.Device.slot)
}

// optional .tec.proto.ComputerScreen computerScreen = 2;
inline bool Computer_Device::has_computerscreen() const {
  return device_case() == kComputerScreen;
}
inline void Computer_Device::set_has_computerscreen() {
  _oneof_case_[0] = kComputerScreen;
}
inline void Computer_Device::clear_computerscreen() {
  if (has_computerscreen()) {
    delete device_.computerscreen_;
    clear_has_device();
  }
}
inline const ::tec::proto::ComputerScreen& Computer_Device::computerscreen() const {
  // @@protoc_insertion_point(field_get:tec.proto.Computer.Device.computerScreen)
  return has_computerscreen() ? *device_.computerscreen_
                      : ::tec::proto::ComputerScreen::default_instance();
}
inline ::tec::proto::ComputerScreen* Computer_Device::mutable_computerscreen() {
  if (!has_computerscreen()) {
    clear_device();
    set_has_computerscreen();
    device_.computerscreen_ = new ::tec::proto::ComputerScreen;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Computer.Device.computerScreen)
  return device_.computerscreen_;
}
inline ::tec::proto::ComputerScreen* Computer_Device::release_computerscreen() {
  if (has_computerscreen()) {
    clear_has_device();
    ::tec::proto::ComputerScreen* temp = device_.computerscreen_;
    device_.computerscreen_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Computer_Device::set_allocated_computerscreen(::tec::proto::ComputerScreen* computerscreen) {
  clear_device();
  if (computerscreen) {
    set_has_computerscreen();
    device_.computerscreen_ = computerscreen;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Computer.Device.computerScreen)
}

inline bool Computer_Device::has_device() const {
  return device_case() != DEVICE_NOT_SET;
}
inline void Computer_Device::clear_has_device() {
  _oneof_case_[0] = DEVICE_NOT_SET;
}
inline Computer_Device::DeviceCase Computer_Device::device_case() const {
  return Computer_Device::DeviceCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Computer_CPU_TR3200

// repeated uint32 registers = 1;
inline int Computer_CPU_TR3200::registers_size() const {
  return registers_.size();
}
inline void Computer_CPU_TR3200::clear_registers() {
  registers_.Clear();
}
inline ::google::protobuf::uint32 Computer_CPU_TR3200::registers(int index) const {
  // @@protoc_insertion_point(field_get:tec.proto.Computer.CPU.TR3200.registers)
  return registers_.Get(index);
}
inline void Computer_CPU_TR3200::set_registers(int index, ::google::protobuf::uint32 value) {
  registers_.Set(index, value);
  // @@protoc_insertion_point(field_set:tec.proto.Computer.CPU.TR3200.registers)
}
inline void Computer_CPU_TR3200::add_registers(::google::protobuf::uint32 value) {
  registers_.Add(value);
  // @@protoc_insertion_point(field_add:tec.proto.Computer.CPU.TR3200.registers)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Computer_CPU_TR3200::registers() const {
  // @@protoc_insertion_point(field_list:tec.proto.Computer.CPU.TR3200.registers)
  return registers_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Computer_CPU_TR3200::mutable_registers() {
  // @@protoc_insertion_point(field_mutable_list:tec.proto.Computer.CPU.TR3200.registers)
  return &registers_;
}

// required uint32 pc = 2;
inline bool Computer_CPU_TR3200::has_pc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Computer_CPU_TR3200::set_has_pc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Computer_CPU_TR3200::clear_has_pc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Computer_CPU_TR3200::clear_pc() {
  pc_ = 0u;
  clear_has_pc();
}
inline ::google::protobuf::uint32 Computer_CPU_TR3200::pc() const {
  // @@protoc_insertion_point(field_get:tec.proto.Computer.CPU.TR3200.pc)
  return pc_;
}
inline void Computer_CPU_TR3200::set_pc(::google::protobuf::uint32 value) {
  set_has_pc();
  pc_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Computer.CPU.TR3200.pc)
}

// required uint32 wait_cycles = 3;
inline bool Computer_CPU_TR3200::has_wait_cycles() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Computer_CPU_TR3200::set_has_wait_cycles() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Computer_CPU_TR3200::clear_has_wait_cycles() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Computer_CPU_TR3200::clear_wait_cycles() {
  wait_cycles_ = 0u;
  clear_has_wait_cycles();
}
inline ::google::protobuf::uint32 Computer_CPU_TR3200::wait_cycles() const {
  // @@protoc_insertion_point(field_get:tec.proto.Computer.CPU.TR3200.wait_cycles)
  return wait_cycles_;
}
inline void Computer_CPU_TR3200::set_wait_cycles(::google::protobuf::uint32 value) {
  set_has_wait_cycles();
  wait_cycles_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Computer.CPU.TR3200.wait_cycles)
}

// required uint32 int_msg = 4;
inline bool Computer_CPU_TR3200::has_int_msg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Computer_CPU_TR3200::set_has_int_msg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Computer_CPU_TR3200::clear_has_int_msg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Computer_CPU_TR3200::clear_int_msg() {
  int_msg_ = 0u;
  clear_has_int_msg();
}
inline ::google::protobuf::uint32 Computer_CPU_TR3200::int_msg() const {
  // @@protoc_insertion_point(field_get:tec.proto.Computer.CPU.TR3200.int_msg)
  return int_msg_;
}
inline void Computer_CPU_TR3200::set_int_msg(::google::protobuf::uint32 value) {
  set_has_int_msg();
  int_msg_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Computer.CPU.TR3200.int_msg)
}

// required bool interrupt = 5;
inline bool Computer_CPU_TR3200::has_interrupt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Computer_CPU_TR3200::set_has_interrupt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Computer_CPU_TR3200::clear_has_interrupt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Computer_CPU_TR3200::clear_interrupt() {
  interrupt_ = false;
  clear_has_interrupt();
}
inline bool Computer_CPU_TR3200::interrupt() const {
  // @@protoc_insertion_point(field_get:tec.proto.Computer.CPU.TR3200.interrupt)
  return interrupt_;
}
inline void Computer_CPU_TR3200::set_interrupt(bool value) {
  set_has_interrupt();
  interrupt_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Computer.CPU.TR3200.interrupt)
}

// required bool step_mode = 6;
inline bool Computer_CPU_TR3200::has_step_mode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Computer_CPU_TR3200::set_has_step_mode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Computer_CPU_TR3200::clear_has_step_mode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Computer_CPU_TR3200::clear_step_mode() {
  step_mode_ = false;
  clear_has_step_mode();
}
inline bool Computer_CPU_TR3200::step_mode() const {
  // @@protoc_insertion_point(field_get:tec.proto.Computer.CPU.TR3200.step_mode)
  return step_mode_;
}
inline void Computer_CPU_TR3200::set_step_mode(bool value) {
  set_has_step_mode();
  step_mode_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Computer.CPU.TR3200.step_mode)
}

// required bool skiping = 7;
inline bool Computer_CPU_TR3200::has_skiping() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Computer_CPU_TR3200::set_has_skiping() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Computer_CPU_TR3200::clear_has_skiping() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Computer_CPU_TR3200::clear_skiping() {
  skiping_ = false;
  clear_has_skiping();
}
inline bool Computer_CPU_TR3200::skiping() const {
  // @@protoc_insertion_point(field_get:tec.proto.Computer.CPU.TR3200.skiping)
  return skiping_;
}
inline void Computer_CPU_TR3200::set_skiping(bool value) {
  set_has_skiping();
  skiping_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Computer.CPU.TR3200.skiping)
}

// required bool sleeping = 8;
inline bool Computer_CPU_TR3200::has_sleeping() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Computer_CPU_TR3200::set_has_sleeping() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Computer_CPU_TR3200::clear_has_sleeping() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Computer_CPU_TR3200::clear_sleeping() {
  sleeping_ = false;
  clear_has_sleeping();
}
inline bool Computer_CPU_TR3200::sleeping() const {
  // @@protoc_insertion_point(field_get:tec.proto.Computer.CPU.TR3200.sleeping)
  return sleeping_;
}
inline void Computer_CPU_TR3200::set_sleeping(bool value) {
  set_has_sleeping();
  sleeping_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Computer.CPU.TR3200.sleeping)
}

// -------------------------------------------------------------------

// Computer_CPU

// optional .tec.proto.Computer.CPU.TR3200 tr3200 = 1;
inline bool Computer_CPU::has_tr3200() const {
  return cpu_case() == kTr3200;
}
inline void Computer_CPU::set_has_tr3200() {
  _oneof_case_[0] = kTr3200;
}
inline void Computer_CPU::clear_tr3200() {
  if (has_tr3200()) {
    delete cpu_.tr3200_;
    clear_has_cpu();
  }
}
inline const ::tec::proto::Computer_CPU_TR3200& Computer_CPU::tr3200() const {
  // @@protoc_insertion_point(field_get:tec.proto.Computer.CPU.tr3200)
  return has_tr3200() ? *cpu_.tr3200_
                      : ::tec::proto::Computer_CPU_TR3200::default_instance();
}
inline ::tec::proto::Computer_CPU_TR3200* Computer_CPU::mutable_tr3200() {
  if (!has_tr3200()) {
    clear_cpu();
    set_has_tr3200();
    cpu_.tr3200_ = new ::tec::proto::Computer_CPU_TR3200;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Computer.CPU.tr3200)
  return cpu_.tr3200_;
}
inline ::tec::proto::Computer_CPU_TR3200* Computer_CPU::release_tr3200() {
  if (has_tr3200()) {
    clear_has_cpu();
    ::tec::proto::Computer_CPU_TR3200* temp = cpu_.tr3200_;
    cpu_.tr3200_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Computer_CPU::set_allocated_tr3200(::tec::proto::Computer_CPU_TR3200* tr3200) {
  clear_cpu();
  if (tr3200) {
    set_has_tr3200();
    cpu_.tr3200_ = tr3200;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Computer.CPU.tr3200)
}

inline bool Computer_CPU::has_cpu() const {
  return cpu_case() != CPU_NOT_SET;
}
inline void Computer_CPU::clear_has_cpu() {
  _oneof_case_[0] = CPU_NOT_SET;
}
inline Computer_CPU::CpuCase Computer_CPU::cpu_case() const {
  return Computer_CPU::CpuCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Computer

// repeated .tec.proto.Computer.Device devices = 1;
inline int Computer::devices_size() const {
  return devices_.size();
}
inline void Computer::clear_devices() {
  devices_.Clear();
}
inline const ::tec::proto::Computer_Device& Computer::devices(int index) const {
  // @@protoc_insertion_point(field_get:tec.proto.Computer.devices)
  return devices_.Get(index);
}
inline ::tec::proto::Computer_Device* Computer::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:tec.proto.Computer.devices)
  return devices_.Mutable(index);
}
inline ::tec::proto::Computer_Device* Computer::add_devices() {
  // @@protoc_insertion_point(field_add:tec.proto.Computer.devices)
  return devices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tec::proto::Computer_Device >&
Computer::devices() const {
  // @@protoc_insertion_point(field_list:tec.proto.Computer.devices)
  return devices_;
}
inline ::google::protobuf::RepeatedPtrField< ::tec::proto::Computer_Device >*
Computer::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:tec.proto.Computer.devices)
  return &devices_;
}

// required bytes ram = 2;
inline bool Computer::has_ram() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Computer::set_has_ram() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Computer::clear_has_ram() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Computer::clear_ram() {
  ram_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ram();
}
inline const ::std::string& Computer::ram() const {
  // @@protoc_insertion_point(field_get:tec.proto.Computer.ram)
  return ram_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Computer::set_ram(const ::std::string& value) {
  set_has_ram();
  ram_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tec.proto.Computer.ram)
}
inline void Computer::set_ram(const char* value) {
  set_has_ram();
  ram_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tec.proto.Computer.ram)
}
inline void Computer::set_ram(const void* value, size_t size) {
  set_has_ram();
  ram_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tec.proto.Computer.ram)
}
inline ::std::string* Computer::mutable_ram() {
  set_has_ram();
  // @@protoc_insertion_point(field_mutable:tec.proto.Computer.ram)
  return ram_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Computer::release_ram() {
  clear_has_ram();
  return ram_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Computer::set_allocated_ram(::std::string* ram) {
  if (ram != NULL) {
    set_has_ram();
  } else {
    clear_has_ram();
  }
  ram_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ram);
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Computer.ram)
}

// required .tec.proto.Computer.CPU cpu = 3;
inline bool Computer::has_cpu() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Computer::set_has_cpu() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Computer::clear_has_cpu() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Computer::clear_cpu() {
  if (cpu_ != NULL) cpu_->::tec::proto::Computer_CPU::Clear();
  clear_has_cpu();
}
inline const ::tec::proto::Computer_CPU& Computer::cpu() const {
  // @@protoc_insertion_point(field_get:tec.proto.Computer.cpu)
  return cpu_ != NULL ? *cpu_ : *default_instance_->cpu_;
}
inline ::tec::proto::Computer_CPU* Computer::mutable_cpu() {
  set_has_cpu();
  if (cpu_ == NULL) {
    cpu_ = new ::tec::proto::Computer_CPU;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Computer.cpu)
  return cpu_;
}
inline ::tec::proto::Computer_CPU* Computer::release_cpu() {
  clear_has_cpu();
  ::tec::proto::Computer_CPU* temp = cpu_;
  cpu_ = NULL;
  return temp;
}
inline void Computer::set_allocated_cpu(::tec::proto::Computer_CPU* cpu) {
  delete cpu_;
  cpu_ = cpu;
  if (cpu) {
    set_has_cpu();
  } else {
    clear_has_cpu();
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Computer.cpu)
}

// optional string rom_file = 4;
inline bool Computer::has_rom_file() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Computer::set_has_rom_file() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Computer::clear_has_rom_file() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Computer::clear_rom_file() {
  rom_file_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_rom_file();
}
inline const ::std::string& Computer::rom_file() const {
  // @@protoc_insertion_point(field_get:tec.proto.Computer.rom_file)
  return rom_file_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Computer::set_rom_file(const ::std::string& value) {
  set_has_rom_file();
  rom_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tec.proto.Computer.rom_file)
}
inline void Computer::set_rom_file(const char* value) {
  set_has_rom_file();
  rom_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tec.proto.Computer.rom_file)
}
inline void Computer::set_rom_file(const char* value, size_t size) {
  set_has_rom_file();
  rom_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tec.proto.Computer.rom_file)
}
inline ::std::string* Computer::mutable_rom_file() {
  set_has_rom_file();
  // @@protoc_insertion_point(field_mutable:tec.proto.Computer.rom_file)
  return rom_file_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Computer::release_rom_file() {
  clear_has_rom_file();
  return rom_file_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Computer::set_allocated_rom_file(::std::string* rom_file) {
  if (rom_file != NULL) {
    set_has_rom_file();
  } else {
    clear_has_rom_file();
  }
  rom_file_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rom_file);
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Computer.rom_file)
}

// -------------------------------------------------------------------

// Component

// optional .tec.proto.Renderable renderable = 1;
inline bool Component::has_renderable() const {
  return component_case() == kRenderable;
}
inline void Component::set_has_renderable() {
  _oneof_case_[0] = kRenderable;
}
inline void Component::clear_renderable() {
  if (has_renderable()) {
    delete component_.renderable_;
    clear_has_component();
  }
}
inline const ::tec::proto::Renderable& Component::renderable() const {
  // @@protoc_insertion_point(field_get:tec.proto.Component.renderable)
  return has_renderable() ? *component_.renderable_
                      : ::tec::proto::Renderable::default_instance();
}
inline ::tec::proto::Renderable* Component::mutable_renderable() {
  if (!has_renderable()) {
    clear_component();
    set_has_renderable();
    component_.renderable_ = new ::tec::proto::Renderable;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Component.renderable)
  return component_.renderable_;
}
inline ::tec::proto::Renderable* Component::release_renderable() {
  if (has_renderable()) {
    clear_has_component();
    ::tec::proto::Renderable* temp = component_.renderable_;
    component_.renderable_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Component::set_allocated_renderable(::tec::proto::Renderable* renderable) {
  clear_component();
  if (renderable) {
    set_has_renderable();
    component_.renderable_ = renderable;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Component.renderable)
}

// optional .tec.proto.Position position = 2;
inline bool Component::has_position() const {
  return component_case() == kPosition;
}
inline void Component::set_has_position() {
  _oneof_case_[0] = kPosition;
}
inline void Component::clear_position() {
  if (has_position()) {
    delete component_.position_;
    clear_has_component();
  }
}
inline const ::tec::proto::Position& Component::position() const {
  // @@protoc_insertion_point(field_get:tec.proto.Component.position)
  return has_position() ? *component_.position_
                      : ::tec::proto::Position::default_instance();
}
inline ::tec::proto::Position* Component::mutable_position() {
  if (!has_position()) {
    clear_component();
    set_has_position();
    component_.position_ = new ::tec::proto::Position;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Component.position)
  return component_.position_;
}
inline ::tec::proto::Position* Component::release_position() {
  if (has_position()) {
    clear_has_component();
    ::tec::proto::Position* temp = component_.position_;
    component_.position_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Component::set_allocated_position(::tec::proto::Position* position) {
  clear_component();
  if (position) {
    set_has_position();
    component_.position_ = position;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Component.position)
}

// optional .tec.proto.Orientation orientation = 3;
inline bool Component::has_orientation() const {
  return component_case() == kOrientation;
}
inline void Component::set_has_orientation() {
  _oneof_case_[0] = kOrientation;
}
inline void Component::clear_orientation() {
  if (has_orientation()) {
    delete component_.orientation_;
    clear_has_component();
  }
}
inline const ::tec::proto::Orientation& Component::orientation() const {
  // @@protoc_insertion_point(field_get:tec.proto.Component.orientation)
  return has_orientation() ? *component_.orientation_
                      : ::tec::proto::Orientation::default_instance();
}
inline ::tec::proto::Orientation* Component::mutable_orientation() {
  if (!has_orientation()) {
    clear_component();
    set_has_orientation();
    component_.orientation_ = new ::tec::proto::Orientation;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Component.orientation)
  return component_.orientation_;
}
inline ::tec::proto::Orientation* Component::release_orientation() {
  if (has_orientation()) {
    clear_has_component();
    ::tec::proto::Orientation* temp = component_.orientation_;
    component_.orientation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Component::set_allocated_orientation(::tec::proto::Orientation* orientation) {
  clear_component();
  if (orientation) {
    set_has_orientation();
    component_.orientation_ = orientation;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Component.orientation)
}

// optional .tec.proto.View view = 4;
inline bool Component::has_view() const {
  return component_case() == kView;
}
inline void Component::set_has_view() {
  _oneof_case_[0] = kView;
}
inline void Component::clear_view() {
  if (has_view()) {
    delete component_.view_;
    clear_has_component();
  }
}
inline const ::tec::proto::View& Component::view() const {
  // @@protoc_insertion_point(field_get:tec.proto.Component.view)
  return has_view() ? *component_.view_
                      : ::tec::proto::View::default_instance();
}
inline ::tec::proto::View* Component::mutable_view() {
  if (!has_view()) {
    clear_component();
    set_has_view();
    component_.view_ = new ::tec::proto::View;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Component.view)
  return component_.view_;
}
inline ::tec::proto::View* Component::release_view() {
  if (has_view()) {
    clear_has_component();
    ::tec::proto::View* temp = component_.view_;
    component_.view_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Component::set_allocated_view(::tec::proto::View* view) {
  clear_component();
  if (view) {
    set_has_view();
    component_.view_ = view;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Component.view)
}

// optional .tec.proto.Animation animation = 5;
inline bool Component::has_animation() const {
  return component_case() == kAnimation;
}
inline void Component::set_has_animation() {
  _oneof_case_[0] = kAnimation;
}
inline void Component::clear_animation() {
  if (has_animation()) {
    delete component_.animation_;
    clear_has_component();
  }
}
inline const ::tec::proto::Animation& Component::animation() const {
  // @@protoc_insertion_point(field_get:tec.proto.Component.animation)
  return has_animation() ? *component_.animation_
                      : ::tec::proto::Animation::default_instance();
}
inline ::tec::proto::Animation* Component::mutable_animation() {
  if (!has_animation()) {
    clear_component();
    set_has_animation();
    component_.animation_ = new ::tec::proto::Animation;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Component.animation)
  return component_.animation_;
}
inline ::tec::proto::Animation* Component::release_animation() {
  if (has_animation()) {
    clear_has_component();
    ::tec::proto::Animation* temp = component_.animation_;
    component_.animation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Component::set_allocated_animation(::tec::proto::Animation* animation) {
  clear_component();
  if (animation) {
    set_has_animation();
    component_.animation_ = animation;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Component.animation)
}

// optional .tec.proto.Scale Scale = 6;
inline bool Component::has_scale() const {
  return component_case() == kScale;
}
inline void Component::set_has_scale() {
  _oneof_case_[0] = kScale;
}
inline void Component::clear_scale() {
  if (has_scale()) {
    delete component_.scale_;
    clear_has_component();
  }
}
inline const ::tec::proto::Scale& Component::scale() const {
  // @@protoc_insertion_point(field_get:tec.proto.Component.Scale)
  return has_scale() ? *component_.scale_
                      : ::tec::proto::Scale::default_instance();
}
inline ::tec::proto::Scale* Component::mutable_scale() {
  if (!has_scale()) {
    clear_component();
    set_has_scale();
    component_.scale_ = new ::tec::proto::Scale;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Component.Scale)
  return component_.scale_;
}
inline ::tec::proto::Scale* Component::release_scale() {
  if (has_scale()) {
    clear_has_component();
    ::tec::proto::Scale* temp = component_.scale_;
    component_.scale_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Component::set_allocated_scale(::tec::proto::Scale* scale) {
  clear_component();
  if (scale) {
    set_has_scale();
    component_.scale_ = scale;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Component.Scale)
}

// optional .tec.proto.CollisionBody collision_body = 7;
inline bool Component::has_collision_body() const {
  return component_case() == kCollisionBody;
}
inline void Component::set_has_collision_body() {
  _oneof_case_[0] = kCollisionBody;
}
inline void Component::clear_collision_body() {
  if (has_collision_body()) {
    delete component_.collision_body_;
    clear_has_component();
  }
}
inline const ::tec::proto::CollisionBody& Component::collision_body() const {
  // @@protoc_insertion_point(field_get:tec.proto.Component.collision_body)
  return has_collision_body() ? *component_.collision_body_
                      : ::tec::proto::CollisionBody::default_instance();
}
inline ::tec::proto::CollisionBody* Component::mutable_collision_body() {
  if (!has_collision_body()) {
    clear_component();
    set_has_collision_body();
    component_.collision_body_ = new ::tec::proto::CollisionBody;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Component.collision_body)
  return component_.collision_body_;
}
inline ::tec::proto::CollisionBody* Component::release_collision_body() {
  if (has_collision_body()) {
    clear_has_component();
    ::tec::proto::CollisionBody* temp = component_.collision_body_;
    component_.collision_body_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Component::set_allocated_collision_body(::tec::proto::CollisionBody* collision_body) {
  clear_component();
  if (collision_body) {
    set_has_collision_body();
    component_.collision_body_ = collision_body;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Component.collision_body)
}

// optional .tec.proto.Velocity velocity = 8;
inline bool Component::has_velocity() const {
  return component_case() == kVelocity;
}
inline void Component::set_has_velocity() {
  _oneof_case_[0] = kVelocity;
}
inline void Component::clear_velocity() {
  if (has_velocity()) {
    delete component_.velocity_;
    clear_has_component();
  }
}
inline const ::tec::proto::Velocity& Component::velocity() const {
  // @@protoc_insertion_point(field_get:tec.proto.Component.velocity)
  return has_velocity() ? *component_.velocity_
                      : ::tec::proto::Velocity::default_instance();
}
inline ::tec::proto::Velocity* Component::mutable_velocity() {
  if (!has_velocity()) {
    clear_component();
    set_has_velocity();
    component_.velocity_ = new ::tec::proto::Velocity;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Component.velocity)
  return component_.velocity_;
}
inline ::tec::proto::Velocity* Component::release_velocity() {
  if (has_velocity()) {
    clear_has_component();
    ::tec::proto::Velocity* temp = component_.velocity_;
    component_.velocity_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Component::set_allocated_velocity(::tec::proto::Velocity* velocity) {
  clear_component();
  if (velocity) {
    set_has_velocity();
    component_.velocity_ = velocity;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Component.velocity)
}

// optional .tec.proto.AudioSource audio_source = 9;
inline bool Component::has_audio_source() const {
  return component_case() == kAudioSource;
}
inline void Component::set_has_audio_source() {
  _oneof_case_[0] = kAudioSource;
}
inline void Component::clear_audio_source() {
  if (has_audio_source()) {
    delete component_.audio_source_;
    clear_has_component();
  }
}
inline const ::tec::proto::AudioSource& Component::audio_source() const {
  // @@protoc_insertion_point(field_get:tec.proto.Component.audio_source)
  return has_audio_source() ? *component_.audio_source_
                      : ::tec::proto::AudioSource::default_instance();
}
inline ::tec::proto::AudioSource* Component::mutable_audio_source() {
  if (!has_audio_source()) {
    clear_component();
    set_has_audio_source();
    component_.audio_source_ = new ::tec::proto::AudioSource;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Component.audio_source)
  return component_.audio_source_;
}
inline ::tec::proto::AudioSource* Component::release_audio_source() {
  if (has_audio_source()) {
    clear_has_component();
    ::tec::proto::AudioSource* temp = component_.audio_source_;
    component_.audio_source_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Component::set_allocated_audio_source(::tec::proto::AudioSource* audio_source) {
  clear_component();
  if (audio_source) {
    set_has_audio_source();
    component_.audio_source_ = audio_source;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Component.audio_source)
}

// optional .tec.proto.Light pointLight = 10;
inline bool Component::has_pointlight() const {
  return component_case() == kPointLight;
}
inline void Component::set_has_pointlight() {
  _oneof_case_[0] = kPointLight;
}
inline void Component::clear_pointlight() {
  if (has_pointlight()) {
    delete component_.pointlight_;
    clear_has_component();
  }
}
inline const ::tec::proto::Light& Component::pointlight() const {
  // @@protoc_insertion_point(field_get:tec.proto.Component.pointLight)
  return has_pointlight() ? *component_.pointlight_
                      : ::tec::proto::Light::default_instance();
}
inline ::tec::proto::Light* Component::mutable_pointlight() {
  if (!has_pointlight()) {
    clear_component();
    set_has_pointlight();
    component_.pointlight_ = new ::tec::proto::Light;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Component.pointLight)
  return component_.pointlight_;
}
inline ::tec::proto::Light* Component::release_pointlight() {
  if (has_pointlight()) {
    clear_has_component();
    ::tec::proto::Light* temp = component_.pointlight_;
    component_.pointlight_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Component::set_allocated_pointlight(::tec::proto::Light* pointlight) {
  clear_component();
  if (pointlight) {
    set_has_pointlight();
    component_.pointlight_ = pointlight;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Component.pointLight)
}

// optional .tec.proto.Light directionalLight = 11;
inline bool Component::has_directionallight() const {
  return component_case() == kDirectionalLight;
}
inline void Component::set_has_directionallight() {
  _oneof_case_[0] = kDirectionalLight;
}
inline void Component::clear_directionallight() {
  if (has_directionallight()) {
    delete component_.directionallight_;
    clear_has_component();
  }
}
inline const ::tec::proto::Light& Component::directionallight() const {
  // @@protoc_insertion_point(field_get:tec.proto.Component.directionalLight)
  return has_directionallight() ? *component_.directionallight_
                      : ::tec::proto::Light::default_instance();
}
inline ::tec::proto::Light* Component::mutable_directionallight() {
  if (!has_directionallight()) {
    clear_component();
    set_has_directionallight();
    component_.directionallight_ = new ::tec::proto::Light;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Component.directionalLight)
  return component_.directionallight_;
}
inline ::tec::proto::Light* Component::release_directionallight() {
  if (has_directionallight()) {
    clear_has_component();
    ::tec::proto::Light* temp = component_.directionallight_;
    component_.directionallight_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Component::set_allocated_directionallight(::tec::proto::Light* directionallight) {
  clear_component();
  if (directionallight) {
    set_has_directionallight();
    component_.directionallight_ = directionallight;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Component.directionalLight)
}

// optional .tec.proto.Light spotLight = 12;
inline bool Component::has_spotlight() const {
  return component_case() == kSpotLight;
}
inline void Component::set_has_spotlight() {
  _oneof_case_[0] = kSpotLight;
}
inline void Component::clear_spotlight() {
  if (has_spotlight()) {
    delete component_.spotlight_;
    clear_has_component();
  }
}
inline const ::tec::proto::Light& Component::spotlight() const {
  // @@protoc_insertion_point(field_get:tec.proto.Component.spotLight)
  return has_spotlight() ? *component_.spotlight_
                      : ::tec::proto::Light::default_instance();
}
inline ::tec::proto::Light* Component::mutable_spotlight() {
  if (!has_spotlight()) {
    clear_component();
    set_has_spotlight();
    component_.spotlight_ = new ::tec::proto::Light;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Component.spotLight)
  return component_.spotlight_;
}
inline ::tec::proto::Light* Component::release_spotlight() {
  if (has_spotlight()) {
    clear_has_component();
    ::tec::proto::Light* temp = component_.spotlight_;
    component_.spotlight_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Component::set_allocated_spotlight(::tec::proto::Light* spotlight) {
  clear_component();
  if (spotlight) {
    set_has_spotlight();
    component_.spotlight_ = spotlight;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Component.spotLight)
}

// optional .tec.proto.VoxelVolumen voxelVolume = 13;
inline bool Component::has_voxelvolume() const {
  return component_case() == kVoxelVolume;
}
inline void Component::set_has_voxelvolume() {
  _oneof_case_[0] = kVoxelVolume;
}
inline void Component::clear_voxelvolume() {
  if (has_voxelvolume()) {
    delete component_.voxelvolume_;
    clear_has_component();
  }
}
inline const ::tec::proto::VoxelVolumen& Component::voxelvolume() const {
  // @@protoc_insertion_point(field_get:tec.proto.Component.voxelVolume)
  return has_voxelvolume() ? *component_.voxelvolume_
                      : ::tec::proto::VoxelVolumen::default_instance();
}
inline ::tec::proto::VoxelVolumen* Component::mutable_voxelvolume() {
  if (!has_voxelvolume()) {
    clear_component();
    set_has_voxelvolume();
    component_.voxelvolume_ = new ::tec::proto::VoxelVolumen;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Component.voxelVolume)
  return component_.voxelvolume_;
}
inline ::tec::proto::VoxelVolumen* Component::release_voxelvolume() {
  if (has_voxelvolume()) {
    clear_has_component();
    ::tec::proto::VoxelVolumen* temp = component_.voxelvolume_;
    component_.voxelvolume_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Component::set_allocated_voxelvolume(::tec::proto::VoxelVolumen* voxelvolume) {
  clear_component();
  if (voxelvolume) {
    set_has_voxelvolume();
    component_.voxelvolume_ = voxelvolume;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Component.voxelVolume)
}

// optional .tec.proto.Computer computer = 14;
inline bool Component::has_computer() const {
  return component_case() == kComputer;
}
inline void Component::set_has_computer() {
  _oneof_case_[0] = kComputer;
}
inline void Component::clear_computer() {
  if (has_computer()) {
    delete component_.computer_;
    clear_has_component();
  }
}
inline const ::tec::proto::Computer& Component::computer() const {
  // @@protoc_insertion_point(field_get:tec.proto.Component.computer)
  return has_computer() ? *component_.computer_
                      : ::tec::proto::Computer::default_instance();
}
inline ::tec::proto::Computer* Component::mutable_computer() {
  if (!has_computer()) {
    clear_component();
    set_has_computer();
    component_.computer_ = new ::tec::proto::Computer;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Component.computer)
  return component_.computer_;
}
inline ::tec::proto::Computer* Component::release_computer() {
  if (has_computer()) {
    clear_has_component();
    ::tec::proto::Computer* temp = component_.computer_;
    component_.computer_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Component::set_allocated_computer(::tec::proto::Computer* computer) {
  clear_component();
  if (computer) {
    set_has_computer();
    component_.computer_ = computer;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Component.computer)
}

// optional .tec.proto.LuaScript luaScript = 100;
inline bool Component::has_luascript() const {
  return component_case() == kLuaScript;
}
inline void Component::set_has_luascript() {
  _oneof_case_[0] = kLuaScript;
}
inline void Component::clear_luascript() {
  if (has_luascript()) {
    delete component_.luascript_;
    clear_has_component();
  }
}
inline const ::tec::proto::LuaScript& Component::luascript() const {
  // @@protoc_insertion_point(field_get:tec.proto.Component.luaScript)
  return has_luascript() ? *component_.luascript_
                      : ::tec::proto::LuaScript::default_instance();
}
inline ::tec::proto::LuaScript* Component::mutable_luascript() {
  if (!has_luascript()) {
    clear_component();
    set_has_luascript();
    component_.luascript_ = new ::tec::proto::LuaScript;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Component.luaScript)
  return component_.luascript_;
}
inline ::tec::proto::LuaScript* Component::release_luascript() {
  if (has_luascript()) {
    clear_has_component();
    ::tec::proto::LuaScript* temp = component_.luascript_;
    component_.luascript_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Component::set_allocated_luascript(::tec::proto::LuaScript* luascript) {
  clear_component();
  if (luascript) {
    set_has_luascript();
    component_.luascript_ = luascript;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Component.luaScript)
}

inline bool Component::has_component() const {
  return component_case() != COMPONENT_NOT_SET;
}
inline void Component::clear_has_component() {
  _oneof_case_[0] = COMPONENT_NOT_SET;
}
inline Component::ComponentCase Component::component_case() const {
  return Component::ComponentCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Entity

// required uint64 id = 1;
inline bool Entity::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Entity::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Entity::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Entity::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Entity::id() const {
  // @@protoc_insertion_point(field_get:tec.proto.Entity.id)
  return id_;
}
inline void Entity::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Entity.id)
}

// repeated .tec.proto.Component components = 2;
inline int Entity::components_size() const {
  return components_.size();
}
inline void Entity::clear_components() {
  components_.Clear();
}
inline const ::tec::proto::Component& Entity::components(int index) const {
  // @@protoc_insertion_point(field_get:tec.proto.Entity.components)
  return components_.Get(index);
}
inline ::tec::proto::Component* Entity::mutable_components(int index) {
  // @@protoc_insertion_point(field_mutable:tec.proto.Entity.components)
  return components_.Mutable(index);
}
inline ::tec::proto::Component* Entity::add_components() {
  // @@protoc_insertion_point(field_add:tec.proto.Entity.components)
  return components_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tec::proto::Component >&
Entity::components() const {
  // @@protoc_insertion_point(field_list:tec.proto.Entity.components)
  return components_;
}
inline ::google::protobuf::RepeatedPtrField< ::tec::proto::Component >*
Entity::mutable_components() {
  // @@protoc_insertion_point(field_mutable_list:tec.proto.Entity.components)
  return &components_;
}

// -------------------------------------------------------------------

// EntityFileList

// repeated string entity_file_list = 1;
inline int EntityFileList::entity_file_list_size() const {
  return entity_file_list_.size();
}
inline void EntityFileList::clear_entity_file_list() {
  entity_file_list_.Clear();
}
inline const ::std::string& EntityFileList::entity_file_list(int index) const {
  // @@protoc_insertion_point(field_get:tec.proto.EntityFileList.entity_file_list)
  return entity_file_list_.Get(index);
}
inline ::std::string* EntityFileList::mutable_entity_file_list(int index) {
  // @@protoc_insertion_point(field_mutable:tec.proto.EntityFileList.entity_file_list)
  return entity_file_list_.Mutable(index);
}
inline void EntityFileList::set_entity_file_list(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tec.proto.EntityFileList.entity_file_list)
  entity_file_list_.Mutable(index)->assign(value);
}
inline void EntityFileList::set_entity_file_list(int index, const char* value) {
  entity_file_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tec.proto.EntityFileList.entity_file_list)
}
inline void EntityFileList::set_entity_file_list(int index, const char* value, size_t size) {
  entity_file_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tec.proto.EntityFileList.entity_file_list)
}
inline ::std::string* EntityFileList::add_entity_file_list() {
  return entity_file_list_.Add();
}
inline void EntityFileList::add_entity_file_list(const ::std::string& value) {
  entity_file_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tec.proto.EntityFileList.entity_file_list)
}
inline void EntityFileList::add_entity_file_list(const char* value) {
  entity_file_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tec.proto.EntityFileList.entity_file_list)
}
inline void EntityFileList::add_entity_file_list(const char* value, size_t size) {
  entity_file_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tec.proto.EntityFileList.entity_file_list)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
EntityFileList::entity_file_list() const {
  // @@protoc_insertion_point(field_list:tec.proto.EntityFileList.entity_file_list)
  return entity_file_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
EntityFileList::mutable_entity_file_list() {
  // @@protoc_insertion_point(field_mutable_list:tec.proto.EntityFileList.entity_file_list)
  return &entity_file_list_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace tec

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_components_2eproto__INCLUDED
